[{"categories":["ECMAScript"],"contents":" 关于 this 如果对于有经验的 JavaScript 开发者来说，this 都是一种非常复杂的机制，那它到底有用在哪里呢？下面来解释一下为什么要使用 this：\nfunction identify() { return this.name.toUpperCase(); } var me = { name: \u0026#34;Kyle\u0026#34; }; var you = { name: \u0026#34;Reader\u0026#34; }; identify.call(me); // Kyle identify.call(you); // Reader  这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify，不用针对每个对象编写不同版本的函数。如果不使用 this，那就需要给 identify 显式传入一个上下文对象。\nfunction identify(context) { return context.name.toUpperCase(); } var me = { name: \u0026#34;Kyle\u0026#34; }; var you = { name: \u0026#34;Reader\u0026#34; }; identify(me); // Kyle identify(you); // Reader  this 提供了一种更优雅的方式来隐式”传递“一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。\n绑定规则 this 的绑定和函数声明的位置没有任何关系，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。。\n当一个函数被调用时，会创建一个执行上下文。这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。\n默认绑定 独立函数调用是最常见的函数调用，也是 this 绑定的默认规则。严格模式下，this 将指向 undefined，非严格模式下将指向全局对象。\nfunction foo() { console.log( this.a ); } var a = 2; foo(); // 2  隐式绑定 隐式绑定需要考虑的是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。\nfunction foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; obj.foo(); // 2  调用位置会使用 obj 上下文来引用函数，即函数被调用时 obj 对象“拥有”或者“包含”函数。隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。\n对象属性引用链中只有最顶层或者说最靠近函数调用的那一层会影响 this 指向，举例来说：\nfunction foo() { console.log(this.a); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42，this 受 obj2 影响  隐式丢失 一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上。\nfunction foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名！ var a = \u0026#34;oops, global\u0026#34;; // a 是全局对象的属性 bar(); // \u0026#34;oops, global\u0026#34;  虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\n一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：\nfunction foo() { console.log(this.a); } function doFoo(fn) { // fn 其实引用的是 foo  fn(); // \u0026lt;-- 调用位置! } var obj = { a: 2, foo: foo }; var a = \u0026#34;oops, global\u0026#34;; // a 是全局对象的属性 doFoo( obj.foo ); // \u0026#34;oops, global\u0026#34;  参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：\nfunction foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var a = \u0026#34;oops, global\u0026#34;; // a 是全局对象的属性 setTimeout(obj.foo, 100); // \u0026#34;oops, global\u0026#34;  JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：\nfunction setTimeout(fn, delay) { fn(); // \u0026lt;-- 调用位置! }  就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this。在一些 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。实际上你无法控制回调函数的执行方式，因此就没有办法控制会影响绑定的调用位置。\n显示绑定 就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？ 可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。\nfunction foo() { console.log(this.a); } var obj = { a: 2 }; foo.call(obj); // 2  通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是new String(..)、new Boolean(..)或者 new Number(..)），这通常被称为“装箱”。\n由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.bind，它的用法如下：\nfunction foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = foo.bind(obj); var b = bar(3); // 2 3 console.log(b); // 5  bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数。\n第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。举例来说：\nfunction foo(el) { console.log(el, this.id); } var obj = { id: \u0026#34;awesome\u0026#34; }; // 调用 foo(..) 时把 this 绑定到 obj [1, 2, 3].forEach(foo, obj); // 1 awesome 2 awesome 3 awesome  这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样可以少些一些代码。\nnew 绑定 在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 1. 创建（或者说构造）一个全新的对象。\n 这个新对象会被执行 [[原型]] 连接。\n 这个新对象会绑定到函数调用的 this。\n 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\nfunction foo(a) { this.a = a; } var bar = new foo(2); console.log(bar.a); // 2   使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。\n优先级 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断:\n 由 new 调用：绑定到新创建的对象。 由 call、apply 或者 bind 调用：绑定到指定的对象。 由上下文对象调用：绑定到那个上下文对象。 默认：在严格模式下绑定到 undefined，否则绑定到全局对象。  绑定例外 我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用 =\u0026gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this，箭头函数的 this 指向的是外部作用域中的 this。\n箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前就已经在使用一种几乎和箭头函数完全一样的模式。\nfunction foo() { var self = this; // lexical capture of this  setTimeout(function () { console.log(self.a); }, 100); } var obj = { a: 2 }; foo.call(obj); // 2  虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。\n总结 要判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序上述优先级来判断 this 的绑定对象。要注意有些调用可能在无意中导致隐式丢失而使用默认绑定规则。\n如果想”更安全“地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。\nES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定。这其实和 ES6 之前代码中的 self = this 机制一样。\n附：实现 call、apply、bind Function.prototype.customCall = function (context = Object.create(null), ...args) { context.fn = this; // this 是调用 call 的函数  const result = context.fn(...args); delete context.fn; // 执行后删除新增属性  return result; } Function.prototype.customApply = function (context = Object.create(null), args = []) { context.fn = this; // this 是调用 call 的函数  const result = context.fn(...args); delete context.fn; // 执行后删除新增属性  return result; } Function.prototype.customBind = function (context, ...args) { const _this = this; return function Bind(...newArgs) { // 考虑是否此函数被继承  if (this instanceof Bind) { return _this.customApply(this, [...args, ...newArgs]) } return _this.customApply(context, [...args, ...newArgs]) } }  上述 call 和 apply 的实现，实际情况需要考虑应用上下文是否可写，在向应用上下文写入调用函数时，最好使用 Symbol 属性，防止覆盖应用上下文原本的内容。手动实现没有什么意义，重点还是要理解 this。\n","date":"19","image":"images/head_one.jpg","permalink":"/blog/javascriptthis-%E6%9C%BA%E5%88%B6/","tags":["JS系列"],"title":"JavaScript：this 机制"},{"categories":["ECMAScript"],"contents":" 内存的生命周期包括分配内存、使用内存和释放内存。有些语言（比如 C 语言）必须手动分配和释放内存，JavaScript 的内存分配过程是在做变量声明赋值时自动完成的。变量完成内存分配之后程序才可以使用进行读写。当程序不需要再使用某些变量时，它们占用的内存就会进行释放，腾出空间。\n内存溢出 程序的运行需要内存，只要程序提出要求，操作系统或者运行时（Runtime）就必须供给内存。程序运行过程中申请的内存大于系统能够提供的内存，导致程序无法申请到足够的内存，这就是内存溢出（Out Of Memory）。\n内存泄漏 不再用到的内存，没有及时释放，就叫做内存泄漏（Memory Leak），内存泄漏与大小无关，并非导致程序卡顿、崩溃才能叫做内存泄漏。\n内存泄漏的堆积，会使内存占用越来越高，轻则影响系统性能，重则导致进程崩溃，尤其是持续运行的服务进程（Daemon）。\n在 Chrome 浏览器的 Performance 功能中，使用 Memory 选项可以帮助开发者查看内存占用，如果内存不是趋于平稳，而是一直上升，则可能发生了内存泄漏。在 Performance 功能中，也可以手动进行垃圾回收。\nNode.js 提供了 process.memoryUsage 方法，process.memoryUsage 返回一个对象，包含了 Node.js 进程的内存占用信息，该对象包含四个字段，单位是字节。判断内存泄漏，以 heapUsed 字段为准。\nconsole.log(process.memoryUsage()) // Prints: // { // rss: 4935680, // heapTotal: 1826816, // heapUsed: 650472, // external: 49879, // arrayBuffers: 9386 // }    rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：”堆“占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 arrayBuffers：分配给 ArrayBuffers 和 SharedArrayBuffers 的内存，包括所有 Node.js 缓冲区   垃圾回收机制 释放内存需要判定哪些变量是需要被回收的，对于像 JavaScript 这样的高级语言来说，内存释放过程是由垃圾回收器自动完成的，垃圾回收器会按照固定的时间间隔，周期性地找出不再继续使用的变量，然后释放其占用的内存。JavaScript 用于确定可回收内存的方法主要有两种：引用计数与标记清除。无论哪种回收机制，全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。\n引用计数 引用计数是被弃用的垃圾回收策略。老版本 IE 的 BOM 和 DOM 对象是使用 C++ 以 COM 对象的形式实现的，COM 的垃圾回收采用的就是引用计数策略。\n引用计数的基本原理是，保存每个对象的引用计数，当引用发生增减时对计数进行更新。引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束（局部变量不再被引用）等时间节点。当一个对象的引用计数变为 0 时，则说明它将来不会再被引用，因此可以释放相应的内存空间。\nconst arr = [1, 2, 3, 4]; console.log(\u0026#39;hello world\u0026#39;);  数组 [1, 2, 3, 4] 是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此这个数组的被引用次数为 1。尽管后面的代码没有用到 arr 变量，它还是会持续占用内存。\nlet arr = [1, 2, 3, 4]; console.log(\u0026#39;hello world\u0026#39;); arr = null;  上面代码中，将 arr 重置为 null，就解除了对 [1, 2, 3, 4] 的引用，引用次数变成了 0，这部分内存就可以被垃圾回收器释放。\n因此，即使有了垃圾回收机制，开发者还是要关注内存占用：那些很占空间的值，一旦不再用到，必须检查是否还存在对它们的引用；如果是的话，就必须手动解除引用。\n实现容易是引用计数算法最大的优点，相当具有普遍性。采用引用计数策略，当对象不再被引用的瞬间就会被释放，由于释放操作是针对每个对象个别执行的，因此和其它算法相比，由 GC 而产生的中断时间就比较短。\n而引用计数最大的缺点，就是无法释放循环引用的对象。以下 marry 函数执行完毕后，bob 和 alice 两个对象由于互相引用，因此引用计数都为 1，即使后续不会再被使用到，也会持续占用内存，不被释放。当我们不使用它们的时候，需要手动切断引用才能回收内存。\nfunction marry(){ let bob = {}; let alice = {}; bob.wife = alice; // bob 引用 alice  alice.husband = bob;\t// alice 引用 bob  return \u0026#34;They are married！\u0026#34;; } marry();  另外，引用计数并不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会不一致，导致内存错误。为了避免这种情况的发生，对引用计数的操作必须采用独占的方式来进行。如果引用操作频繁发生，每次都要使用加锁等并发控制机制的话，其开销也是不可小觑的。综上所述，引用计数方式的原理和实现虽然简单，但缺点也很多，因此基本上不再被使用。现在，依然采用引用计数方式的语言主要有 Perl 和 Python，但它们为了避免循环引用的问题，都配合使用了其他的 GC 机制。这些语言中，GC 基本上是通过引用计数方式来进行的，但偶尔也会用其他的算法来执行 GC，这样就可以将引用计数方式无法回收的那些对象处理掉。\n标记清除 标记清除（Mark and Sweep）是最早开发出的 GC 算法（1960年）。Node.js 的 global 对象和 JavaScript 的 window 对象，被称作”根“，标记清除首先从根开始，将可能被引用的对象用递归的方式进行标记，标记阶段完成时，被标记的对象就被视为”存活“对象。然后将没有标记到的对象作为垃圾进行回收。\n零引用的对象肯定是需要被回收的，反过来，需要被回收的对象却不一定是零引用（循环引用）。因此标记清除可以有效解决循环引用的问题。在上面的循环引用示例中，marry 函数调用返回之后，两个对象从全局对象出发无法获取。因此，它们将会被垃圾回收器回收。\n从 2012 年起，所有现代浏览器都使用了标记清除垃圾回收算法。所有对 JavaScript 垃圾回收算法的改进都是基于标记清除算法的改进（如 V8 引擎的垃圾回收机制）。\n","date":"19","image":"images/head_two.jpg","permalink":"/blog/javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","tags":["JS系列"],"title":"JavaScript：内存管理"},{"categories":["ECMAScript"],"contents":" 词法作用域 作用域是一套规则，这套规则用来管理引擎如何在当前的作用域以及嵌套的子作用域中根据标识符名称进行变量查找。作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫做动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。JavaScript 中的作用域就是词法作用域。\n词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n欺骗词法 如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（即欺骗）词法作用域呢？\nJavaScript 中有两种机制来实现这个目的：eval(..) 函数和 with 关键字。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。\n这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。避免使用它们。\n动态作用域 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。\n因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。\nfunction foo() { console.log(a) // 3(不是 2 !) } function bar() { var a = 3 foo() } var a = 2 bar()  为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。\n需要明确的是，事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。但是 this 机制某种程度上很像动态作用域。\n词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。\n函数作用域和块作用域 函数是 JavaScript 中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。但函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 { .. } 内部）。\n从 ES3 开始，try/catch 结构在 catch 分句中具有块作用域，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。在 ES6 中引入了 let 和 const 关键字，用来在任意代码块中声明变量。\n函数作用域常被用于隐藏内部实现、规避命名冲突和模块管理等用途，如常用的立即执行函数表达式。\nvar a = 2 (function foo() { var a = 3 console.log(a) // 3 })() console.log(a) // 2  提升 变量声明和函数声明在编译阶段会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。在提升过程中，函数声明优先。\n闭包 function foo() { var a = 2 function bar() { console.log(a) } return bar } var baz = foo() baz() // 2 —— 这就是闭包的效果。  函数 bar() 的词法作用域能够访问 foo() 的内部作用域。在 foo() 执行后，其返回值 bar 函数赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。\n在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。\n而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域？就是 bar() 本身在使用。\n函数在当前词法作用域之外执行时，依然可以记住并访问其所在的词法作用域，这时就产生了闭包。\n在定时器、事件监听器、 AJAX 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！\n由于闭包会使得外层函数中的变量常驻内存，消耗较大，因此不能滥用闭包，否则会造成网页的性能问题，使用不当会很容易造成内存泄露。闭包不在使用时，需要将内层函数变量赋值为 null，等待垃圾回收。\n循环和闭包 for (var i = 1; i \u0026lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000) }  这段代码在运行时会以每秒一次的频率输出五次 6，而非预期的从 1 到 5。延迟函数的回调会在循环结束时才执行，当定时器运行时即使每个迭代中执行的是 setTimeout(.., 0)，所有的回调函数依然是在循 环结束后才会被执行，因此会每次输出一个 6 出来。\n通过闭包修正：\nfor (var i = 1; i \u0026lt;= 5; i++) { (function (j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i) }  防抖（debounce） 防抖即防止抖动，以免事件被频繁触发的同时，执行回调函数，浪费计算资源。防抖所应用的场景：\n 登录、发短信等按钮需要处理用户的频繁点击，以避免多次请求发送请求 input 关联搜索展示下拉选择，当用户输入频率变慢到一定标准时执行请求 调整浏览器窗口大小时，resize 不断出发事件函数，造成频繁计算 文本编辑器实时保存，当无任何更改操作数秒后进行保存请求  防抖的原理是，事件触发时给回调函数添加有延迟的定时器，如果在延迟时间内事件再次被触发，则使用 clearTimeout 清除定时器。\nconst debounce = (func, delay) =\u0026gt; { let timer return (...args) =\u0026gt; { clearTimeout(timer) timer = setTimeout(() =\u0026gt; { func.apply(this, [args]) }, delay) } } const debounceMousemove = debounce(e =\u0026gt; { console.log(`Event data：${e}`) }, 300) document.addEventListener(\u0026#39;mousemove\u0026#39;, function (e) { console.log(\u0026#39;mousemove\u0026#39;) debounceMousemove(e) })  节流（throttle） 节流即控制流量，首先选择适当的间隔时间如 1s，事件被频繁触发期间，固定每隔 1s 执行一次事件回调函数。节流的应用场景：\n 监听 scroll 事件，当滑到底部自动加载更多的内容，用节流降低计算频率 音视频播放时，每隔 1s 计算一次进度信息  相对于防抖，节流的重点在加锁，只要定时器存在便不理会，否则添加定时器，并在其执行后使用赋值为 null 的方式清除定时器。\nconst throttle = (func, interval) =\u0026gt; { let timer return (...args) =\u0026gt; { if (timer) { return } timer = setTimeout(() =\u0026gt; { func.apply(this, [args]) timer = null }, interval) } } const throttleMousemove = throttle(e =\u0026gt; { console.log(`Event data：${e}`) }, 500) document.addEventListener(\u0026#39;mousemove\u0026#39;, function (e) { console.log(\u0026#39;mousemove\u0026#39;) throttleMousemove(e) })  单例模式 class UserSingleton { constructor(name) { this.name = name this.getName() } getName() { return this.name } } const Singleton = (function () { let instance = null return function (name) { if (!instance) { instance = new UserSingleton(name) } return instance } })() const bob = Singleton(\u0026#34;bob\u0026#34;) const jack = Singleton(\u0026#34;jack\u0026#34;) console.log(bob === jack) // true console.log(bob, jack)\t// UserSingleton { name: \u0026#39;bob\u0026#39; } UserSingleton { name: \u0026#39;bob\u0026#39; }  模块化 var Module = (function Manager() { var modules = {} function define(name, deps, impl) { for (var i = 0; i \u0026lt; deps.length; i++) { deps[i] = modules[deps[i]] } modules[name] = impl.apply(impl, deps) } function get(name) { return modules[name] } return { define: define, get: get } })() ","date":"18","image":"images/head_three.jpg","permalink":"/blog/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/","tags":["JS系列"],"title":"JavaScript：作用域和闭包"},{"categories":["网络"],"contents":" HTTP 的缺点 HTTP 具有相当优秀的和方便的一面，简单、灵活、易于扩展是它显著的特点。然而 HTTP 并非只有好的一面，事物皆具有两面性，它也有不足之处。\n明文通信 HTTP 本身不具备加密的功能，无法做到对通信整体进行加密。按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包，然后使用抓包或嗅探器工具对收集来的数据包进行解析即可。\n不验证通信方的身份 HTTP 协议中的请求和响应不会对通信方进行确认，任何人都可以发起请求。服务器只要接收到请求，并且发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问，不管对方是谁都会返回一个响应，这样会存在以下隐患：无法确定请求的目标服务器是否是按真实意图返回响应的那台服务器，有可能是已伪装的 Web 服务器；无法确定响应返回的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端；无法确定正在通信的对方是否具备访问权限；无法判定请求是来自何方、出自谁手；即使是无意义的请求也会照单全收，无法阻止海量请求下的 DoS 攻击\n无法证明报文完整性 完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，如果请求或响应遭到篡改，也没有办法获悉。\nHTTPS 是什么 HTTPS（HTTP Secure）并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL（Secure Socket Layer） 或 TLS（Transport Layer Security）协议代替而已。当使用 SSL/TLS 时，HTTP 先和 SSL/TLS 通信，再由 SSL/TLS 和 TCP 通信。在采用 SSL/TLS 后，HTTP 就拥有了 HTTPS 的加密、认证和完整性保护这些功能。\nSSL 技术最初是由网景公司率先倡导的，开发过 SSL3.0 之前的版本，目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TLS 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前的主流协议是 SSL3.0 和 TLS，SSL1.0 在设计之初被发现出了问题，就没有实际投入使用。SSL2.0 也被发现存在问题，所有很多浏览器直接废除了该协议版本。\nHTTPS = HTTP + 加密 + 认证 + 完整性保护 对称加密 对称加密使用同一串密钥加密和解密，因此被称做对称加密，常见的对称加密算法有 DES、3DES、AES、Blowfish、IDEA、RC5 和 RC6 等。对称加密通常使用的是相对较小的密钥，一般小于 256bit。密钥越大，加密越强，但加密与解密的过程越慢。密钥的大小既要照顾到安全性，也要照顾到效率。\n对称加密的缺点是密钥的管理与分配，在发送密钥的过程中，密钥有很大的风险会被黑客们拦截，如何将对称密钥安全地交付给对方是一个问题。\n非对称加密 非对称加密算法需要两个密钥：公开密钥（简称公钥）和私有密钥（简称私钥）。公钥与私钥是一对，公钥加密的信息，只有私钥才能解密；反之，私钥加密的信息，只有公钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。RSA 算法是应用最广泛的非对称加密算法，具体原理可参考文章：RSA算法原理（一） 和 RSA算法原理（二）。\n非对称加密算法实现机密信息交换的基本过程是：甲生成一对密钥并将公钥公开，需要向甲发送信息的乙用甲的公钥对信息进行加密后再发送给甲；甲再用自己的私钥对加密后的信息进行解密。甲想要回复乙时正好相反，使用乙的公钥对数据进行加密，同理，乙使用自己的私钥来进行解密。\n虽然非对称加密更安全，但和对称加密相比，加解密的效率低很多，所以理想状态是用对称加密来传送消息，通过非对称加密的方式发送对称加密所使用的密钥，这正是 HTTPS 所采用的方式。\nHTTPS 加密 HTTPS 加密的过程可以参考以下案例：\n Alice 需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。 Alice 的浏览器向银行的网站请求公钥。 银行将公钥发送给 Alice。 Alice 的浏览器使用银行的公钥将自己的对称密钥加密。 Alice 的浏览器将加密后的对称密钥发送给银行。 银行使用私钥解密得到 Alice 浏览器的对称密钥。 Alice 与银行可以使用对称密钥来对沟通的内容进行加密与解密了。  这个过程中，公钥是公开分发的，任何人都可以拿到公钥，只有银行的私钥能对公钥加密的信息进行解密。所以，即使信息被截取，没有银行的私钥，也无法知晓信息的内容。\n但是这里又有新的问题，既然网络是不安全的，那么银行发给 Alice 的公钥就有被截取和篡改的可能。按照这个思路来，黑客在银行返回给 Alice 公钥时，完全可以将公钥替换成黑客自己的公钥，Alice 拿到公钥以后将对称密钥进行加密，发送银行。此时黑客用自己的私钥解密出对称密钥，再使用银行的公钥加密对称密钥发送银行，到此，Alice 和银行双方都不会发现异常，之后继续进行通信，而黑客却能一直监听和获取后续通信的内容。\n综上，由于通信内容明文有安全隐患，采用了对称密钥加密通信内容，但对称密钥暴露的风险较大，因此使用非对称加密传送对称密钥，但非对称加密同样有公钥被截取篡改的风险。只要保证公钥安全的传送给通信方，就能保证对称密钥的安全性，整个通信过程也就安全了，这就是数字签名和数字证书的来历。\n签名和证书 为了保证服务器返回的公钥是未被篡改的，有了 CA（Certificate Authority）的概念，就是证书授权机构，是第三方的权威机构，虽然历史上也有 CA 机构被攻破的例子，但理论上是权威可靠的。\n服务器要申请证书，首先要向 CA 机构提供公钥、组织信息、域名等信息并申请认证，CA 通过线上、线下等多种手段验证申请者提供信息的真实性，如组织是否存在、企业是否合法，是否拥有域名的所有权等。审核通过后，CA 机构会向申请者签发认证文件 \u0026mdash; 证书。证书包含以下信息：申请者公钥、申请者的组织信息和个人信息、签发机构的信息、有效时间、证书序列号等信息的明文，同时包含一个签名。\nCA 机构有一对公、私钥，它把申请者的个人信息以及公钥信息用他的私钥加密成密文，把这个密文当做电子签名签在了证书上，这个证书就被称为电子证书，最后再把自己的公钥给客户端，那么客户端收到 CA 机构给的证书之后，就可以利用 CA 机构给的公钥解密证书上面的签名，客户端最后将解密出来的服务器公钥去加密对称密钥，将之发送服务器进行后续通信。\n证书 = 服务器公钥 + 服务器与颁发者信息 + 签名，证书的安全性依靠签名保证，签名即 CA 机构的公钥加密后的密文。\n中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行修改证书，就会导致证书内容和证书签名不匹配。\n截止目前，又会有新的问题，即如何获取 CA 机构的公钥，又如何保证 CA 机构公钥的正确性呢？其实，操作系统或浏览器会预装第三方 CA 机构的证书，如此免去互联网上传输的风险，正因如此，用户需要安装正版的操作系统和可信任的官方浏览器，否则，基础都不安全，上层应用也就没有安全性保障。\n综上，首先我们要理解，CA 机构的公钥已经预存到了客户端，理论安全。CA 机构在认证了服务方后，会生成证书，交给服务方，证书 = 服务器公钥 + 服务器与颁发者信息 + 签名，签名即 CA 机构公钥加密的证书内容。客户端在与服务器通信时，服务器首先返回证书，客户端用 CA 机构的公钥解密来验证证书内容和签名信息是否一致，一致则利用服务器公钥进行后续通信。在这个过程中，中间人由于没有 CA 机构密钥，即使用 CA 机构的公钥解密证书内容，也无法进行加密，只有用 CA 机构私钥加密的内容，才能用 CA 机构的公钥解密，因此，中间人无从下手。\n散列函数 Hash 保证完整性 常见的散列函数有 MD5、SHA1、SHA256，该类函数特点是函数单向不可逆、对输入非常敏感、输出长度固定，针对数据的任何修改都会改变散列函数的结果，用于防止信息篡改并验证数据的完整性。\n在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。\n通过这种加密方式生成数字签名，从而保证数据的完整性。 将一段文本用 Hash 函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文一起传送给接收者。\n接收者用发送者的公钥解密被加密的摘要信息，然后用 Hash 函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。\nHTTPS 的缺点 HTTPS 普遍被认为性能消耗要大于 HTTP，因为与纯文本通信相比，加密通信会消耗更多的 CPU 及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量也会随之减少。\n除此之外，要进行 HTTPS 通信，证书是必不可少的。而使用的证书必须向 CA 机构购买。\n总结 HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：对称加密、非对称加密和散列函数，利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。\n","date":"15","image":"images/head_four.jpg","permalink":"/blog/%E7%A1%AE%E4%BF%9D-web-%E5%AE%89%E5%85%A8%E7%9A%84-https/","tags":["HTTP","安全"],"title":"确保 Web 安全的 HTTPS"},{"categories":["网络"],"contents":" HTTP 缓存通过资源复用，可以减轻服务器负担，显著提高网站和应用程序的性能。HTTP 缓存主要有客户端缓存和代理缓存，其它还包括网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式。HTTP 缓存主要存储 GET 响应。\n以 Chrome 为例，打开新标签页后调出 DevTools，将功能切至 NetWork，首次访问 Google 搜索页面，能看到请求：\nctrl + r 刷新页面，可看到请求：\n在 Size 一栏中，可以看到部分资源来自 Memory Cache，部分来自 Disk Cache，其余从服务器获取。在首次访问页面之后，浏览器会将资源缓存，后续访问这些资源时，可直接从缓存中获取，不必再从服务器下载。\n根据是否需要重新向服务器发起请求来分类，可以将 HTTP 缓存分为两类：强缓存和协商缓存。强缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。强缓存的优先级高于协商缓存。\n强缓存 强缓存指首次向服务器发起资源请求后，服务器会告知客户端资源缓存的有效时间，有效期内直接从客户端缓存中读取，不必与服务器交互。强缓存通过 Expires 和 Cache-Control 首部字段来实现，后者优先级更高。\nExpires HTTP/1.0 定义了 Expires 响应首部字段，用于告知客户端资源缓存的过期时间，在过期时间之前请求资源直接使用缓存，不需要再次请求服务器（排除其它首部字段干扰的情况下）。\nExpires: Mon, 25 Jan 2021 23:04:06 GMT Expires 过期时间由服务器生成，是否过期的判定最终需要参考客户端时间。客户端和服务器时间可能不一致，而且客户端的时间是可以自行修改的，修改客户端时间可能导致缓存失效（如浏览器时间参考操作系统时间，修改系统时间会影响到缓存），所以不一定满足预期。\nCache-Control 为弥补 Expires 的缺点，HTTP/1.1 新增了 Cache-Control 通用首部字段，时间值为相对时间，且不依赖客户端时间，优先级高于 Expires。\n   指令 类型 说明     no-cache 通用 资源正常缓存，但使用前必须进行协商校验   no-store 通用 禁用所有缓存，从源服务器获取资源   public 响应 共享缓存（中间代理和 CDN等）和私有缓存（客户端）都可以缓存响应，缺省值为 private   private 响应 只有私有缓存可以缓存响应   max-age = N 响应 缓存有效期（单位秒），为 0 时与 no-cache 效果一致   s-maxage = N 响应 覆盖 max-age，只适用于共享缓存，私有缓存会忽略   must-revalidation 响应 在缓存过期前可以使用，过期（如缓存时间超过 max-age）后必须向服务器验证   proxy-revalidation 响应 与 must-revalidate 作用相同，但仅适用于共享缓存，私有缓存会忽略。   no-transform 通用 代理不可更改媒体类型如 Content-Encoding、Content-Range、Content-Type    对于那些改动频率极低的资源如 CSS 或 JS 库，常见的做法是将 max-age 的值设为 31536000，代表一年内缓存有效。如果在缓存有效期内，内容资源内容发生了改动，可以修改资源名称，如在资源名称中加版本号或生成随机 hash。\nPragma Pragma 是 HTTP/1.0 标准中定义的一个首部字段，Pragma 只有一个值 no-cache，效果跟 Cache-Control: no-cache 效果相同，请求中一般会额外添加 Pragma 以兼容基于 HTTP/1.0 的服务器。\nCache-Control: no-cache Pragma: no-cache 协商缓存 协商缓存是指在强缓存失效后，客户端携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存，缓存有效返回 304 Not Modified，否则返回响应内容。协商缓存使用 「Last-Modified/If-Modified-Since」和「ETag/If-None-Match」两对首部字段作为标识确定缓存是否有效，后者优先级更高。\nLast-Modified 客户端首次访问资源时，服务器返回首部字段 Last-Modified 表明资源在服务器最近修改的时间，客户端在后续请求资源时会将这个时间放在请求首部的 If-Modified-Since 中。服务器收到这个请求，会对比 If-Modified-Since 和服务器上这个资源的最后修改时间：如果一致就返回 304 Not Modified，让客户端直接从缓存里读取；如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有新的编辑，缓存失效，返回新的资源文件。\nEtag 客户端首次访问资源时，服务器返回首部字段 Etag，Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识，客户端在后续请求此资源的时会将 Etag 值放在请求首部的 If-None-Match 中。服务器收到这个请求，会对比 If-None-Match 和服务器上这个资源的 Etag：如果一致就返回 304 Not Modified，让客户端直接从缓存里读取；否则说明文件内容有更新，缓存失效，返回新的资源文件。\nEtag 的值为 W/ 开头时，说明使用的是弱 Etag。弱 Etag 匹配只要求两个资源在语义上相等，强 Etag 匹配要求其它实体字段如 Content-Language 也要一致。\n若资源是分布式服务器（如 CDN）存储的情况，需要这些服务器上计算 ETag 的算法保持一致，才不会导致同一个文件，多台服务器返回的 ETag 却不一样。\nIf-Unmodified-Since 和 If-Match 这两个请求首部字段与缓存关系不大，If-Unmodified-Since 条件请求是只有当资源在指定的时间之后没有修改的情况下，服务器才会返回请求的资源，或是接受 POST 或其它 non-safe 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 412 Precondition Failed 错误。\nIf-Match 条件请求在请求方法为 GET 和 HEAD 的情况下，服务器仅在请求的资源满足此首部列出的 ETag 值时才会返回资源。而对于 PUT 或其它非安全方法来说，只有在满足条件的情况下才可以将资源上传。\n浏览器缓存 前面提到的强缓存和协商缓存根本上来说是缓存策略，资源具体的缓存位置实际只有内存和磁盘，在浏览器中包括非持久化的 Memory Cache、Push Cache 和持久化的 Disk Cache、Service Worker 共四类缓存。\nMemory Cache 有效时间不超过 Tab 的存活周期，Tab 被关闭时释放，具体释放时机取决于浏览器策略。Memory Cache 会忽略 Cache-Control 被标记为 max-age=0 或 no-cache 的情况，此时资源仍可被放入 Memory Cache ，当值为 no-store 时，才不会被放入 Memory Cache。\nMemory Cache 使得页面中的同一地址资源只需要进行一次请求，但当请求类型不同时，不会使用 Memory Cache，如脚本和样式表使用同一地址资源，会进行两次请求。预加载资源一般也存放在 Memory Cache 中。\nService Worker 是运行在浏览器中的独立线程，可实现离线缓存、消息推送和网络代理等功能，而 Push Cache 是 HTTP/2 中的新内容。\n浏览器缓存调用的优先关系是：Memory Cache \u0026gt; Service Worker \u0026gt; Disk Cache \u0026gt; Push Cache，若在以上四个缓存中均未找到有效的缓存资源，将对服务器发起资源的请求。\nAJAX 和 Fetch Ajax 和 Fetch 中的 Get 请求通常会被用作等幂操作，前面讨论的 HTTP 缓存机制依然适用。\n用户行为 用户行为对浏览器缓存的影响有以下几种（仅讨论 Memory Cache 和 Disk Cache）：\n Tab 输入 URI 回车：先检测强缓存是否有效，有效则从 Disk Cache 获取资源；强缓存无效则发送请求协商，若协商缓存有效服务器返回 304 状态码，浏览器依旧从 Disk Cache 获取资源；协商缓存也无效时，服务器会返回资源内容主体。 普通刷新：首先查看 Memory Cache 是否有效，有效直接从 Memory Cache 获取资源；无效则按「Tab 输入 URI 回车」步骤执行。 强制刷新：浏览器不使用任何本地缓存而直接发送请求，头部带有 Cache-Control: no-cache 和 Pragma: no-cache，并且不会在请求中携带协商缓存字段。 DevTools 选中 Disable Cache：效果与「强制刷新」一样  以上使用强制刷新，只是代表浏览器不使用任何本地缓存，但代理缓存依旧可能生效。\n其它缓存首部字段 Date Date 通用首部包含了报文创建的日期和时间。Date 在响应中说明响应生成的时间，请求经过代理服务器时, 返回的 Date 未必是最新的，通常这个时候，代理服务器将增加一个 Age 字段告知该资源已缓存了多久。\nAge Age 响应首部字段里包含资源在缓存代理中存贮的时长，单位为秒。\nAge: 40152 Date: Fri, 05 Feb 2021 16:58:00 GMT 以上响应意为代理服务器在 2021 年 2 月 5 日 16:58:00 时向源服务器发起了对该资源的请求，目前已缓存了该资源 741427 秒。\nVary 通过 Vary 响应首部字段，源服务器会向代理服务器传达关于本地缓存使用方法的指令。代理服务器接收到源服务器包含 Vary 的响应后，缓存对应资源，后续仅对 Vary 值属性一样的请求返回此缓存。即使对相同资源发起请求，但由于 Vary 指定的首部字段不相同，因此必须要从源服务器重新获取资源。\n举例来说，同一 URL 的资源，根据客户端 Accept-Language 值的不同，需要内容不同的资源文件。中文客户端用户请求资源后，代理服务器进行了缓存：如果没有指定 Vary: Accept-Language，那么后续所有客户端将只能使用这份中文内容的缓存；如果指定 Vary: Accept-Language，那么只有中文客户端才会使用代理服务器的这份缓存。\nVary: Accept-Encoding, Accept-Language, User-Agent 如上设置，代理服务器将根据客户端支持的编码类型、自然语言和用户代理（如 PC、Android、iOS 等）三个方面去缓存资源。如此，同一路径的资源，就能针对这三者的不同，返回对应的缓存内容，避免返回同一缓存。\n","date":"09","image":"images/head_five.jpg","permalink":"/blog/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-http-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","tags":["HTTP"],"title":"深入浅出 HTTP 缓存机制"},{"categories":["DevOps"],"contents":" Mac OS 持久化别名指定 在终端中执行的 alias 命令指定的别名仅本次登录有效，若需使别名永久生效，可以执行 vi ~/.bashrc，在文件末尾中添加行：\nub2=\u0026#39;ssh ubuntu@139.155.86.169\u0026#39; 保存退出后，使用 source 命令刷新环境变量后即可使用自定义的 ub2 命令：\nsource ~/.bashrc 如果系统使用的是 zsh，编辑配置 ~/.zshrc 即可，终端执行 echo $0 可查看当前使用的 shell 类型。\nLinux 拷贝命令 cp、rcp 和 scp cp Linux cp 命令语法：\ncp [options] source destination cp [options] source... directory [options] 参数说明： - -d：复制时保留链接 - -p：除复制文件的内容外，还保留源文件或目录的属性，包括所有者、所属组、权限与修改时间也复制到新文件中 - -r：若给出的源文件是一个目录，将复制该目录下所有的子目录和文件 - -a：通常在复制目录时使用，表示保留链接、文件属性，并复制目录下的所有内容。作用等于 -dpR 参数组合\nLinux cp 命令使用实例：\ncp index.html dir cp –r dir newdir scp rcp 通过 RSH（Remote Shell）来执行远程命令，不够安全，现已被 scp 取代。scp 是「secure copy」的缩写，是 Linux 系统下基于 SSH（Secure Shell） 登录进行安全地远程文件拷贝命令，scp 命令语法：\nscp [options] source username@ip:destination scp [options] source... username@ip:directory scp [options] username@ip:source destination scp [options] username@ip:source... directory scp 命令中的远程地址可以是 IP 地址或域名，最常用参数是 -r 递归复制，如果远程服务器防火墙为 scp 命令设置了指定的端口，使用 -P 参数设置端口。执行命令后，需要输入用户登录密码，由于 scp 基于 SSH，因此可以将本地公钥存放在远程主机 ~/.ssh/authorized_keys 文件中，免去每次执行命令时输入密码的麻烦。\nscp 命令使用实例：\nscp temp/temp.txt ubuntu@www.soupcraft.icu:/tmp scp -r temp/ ubuntu@www.soupcraft.icu:/tmp scp ubuntu@www.soupcraft.icu:/tmp/tmp.txt temp scp -r ubuntu@www.soupcraft.icu:/tmp temp Linux 压缩与解压缩 Linux 支持的压缩指令可以通过不同的后缀名进行区分：\n .zip：用 zip 命令压缩，unzip 命令解压。 .gz：用 gzip 命令压缩，gzip 命令只能压缩文件，可用 gzip -d 或 gunzip 解压。 .bz2：用 bzip2 命令压缩，可用 bzip2 -z 或 bunzip2 解压。 .xz：用 xz -z 命令压缩，xz -d 命令解压。  通常，如果只有一个大文件，使用以上命令进行压缩是十分合适的。但更常见的情况是，需要压缩有很多子目录和文件的目录，这种情况一般先通过 tar 命令进行归档，然后再使用以上命令压缩归档文件。\n# 打包 tar -cvf destination.tar source1 source2 # 解包 tar -xvf destination.tar 参数说明： - -c: create，创建一个归档 - -x: extract，将文件从归档中提取出来 - -v: verbose，详细的将文件列表信息打印出来 - -f: file，从归档文件中操作\n在产出 .tar 归档文件过后，即可使用上述压缩命令进行压缩产出后缀为 .tar.gz、.tar.bz2、.bar.xz 的压缩文件。实际上，tar 命令除归档之外，已经提供了参数供快捷调用 gzip 和 bzip2 功能：\ntar -czvf /tmp/etc.tar.gz /etc tar -xzvf /tmp/etc.tar.gz /etc tar -cjvf /tmp/etc.tar.bz2 /etc tar -xjvf /tmp/etc.tar.bz2 /etc  -z 参数代表使用 gzip 命令对文件进行压缩或解压缩，-j 参数代表使用 bzip2 命令对文件进行压缩或解压缩。\n生成 SSH 密钥 ssh-keygen 命令用于为 SSH 生成、管理和转换认证密钥，默认使用 RSA 算法（SSH2 协议还支持 DSA 算法），长度为 2048 位，生成一个私钥文件 id_rsa 和一个公钥文件 id_rsa.pub，两个文件默认保存在用户的 ~/.ssh 目录下。\n创建一个默认密钥对：\nssh-keygen 使用 -t 参数创建指定的密钥类型，并添加注释：\nssh-keygen -t rsa -C \u0026#34;注释\u0026#34; 常见于客户端生成 Git 相关公钥，-C 参数指定密钥名称，邮箱地址作为密钥名称较常见，但实际就是一个标识，可任意命名。\nSSH 连接超时中断的解决办法 修改服务器 SSH 配置 编辑服务器 /etc/ssh/sshd_config 文件，修改为：\n# 服务器每隔 60 秒发送一次请求给客户端，客户端响应则保持连接 ClientAliveInterval 60 # 服务器未被响应次数达到 5 次就自动断开连接 ClientAliveCountMax 5 修改客户端 SSH 配置 编辑客户端 /etc/ssh/sshd_config 文件，修改为：\n# 客户端每隔 60 秒发送一次请求给服务器，服务器响应则保持连接 ServerAliveInterval 60 # 客户端未被响应次数达到 5 次就自动断开连接 ServerAliveCountMax 5","date":"05","image":"images/head_six.jpg","permalink":"/blog/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%A1%8C/","tags":null,"title":"常用的一些命令行"},{"categories":["随笔"],"contents":" 2021 年 1 月 1 日 昨日夜，辗转反侧，难以入眠，遂相邀叙旧，与约酒肆。唯李兄至。恰新旧交替，聚者甚多，宾客盈门，不逢时，门口落座，饮至翌年，谈古说今，甚欢。\n酒后难舍，蓉城街头，阔步高谈，行至天明。东谈西说，过眼云烟，唯二三事，言犹在耳。\n卜数只偶，故地重游。负笈求学，于兹三载，东劳西燕，距此又两年有余。昔日同窗，各自文采风流，为余所钦，今关山阻隔，天涯沦落，忾然叹息。\n 残腊即又尽，东风应渐闻。\n一宵犹几许，两岁欲平分。\n燎暗倾时斗，春通绽处芬。\n明朝遥捧酒，先合祝尧君。\n ","date":"01","image":"images/head_seven.jpg","permalink":"/blog/%E5%8F%B9%E6%B5%81%E5%B9%B4/","tags":null,"title":"叹流年"},{"categories":["HTML"],"contents":" HTML5 文档的第一行就是 \u0026lt;!DOCTYPE html\u0026gt; 用于文档声明。首先，这不是 HTML 标签，DOCTYPE 意为文档类型，这段代码用于文档类型声明。其次，文档类型声明应尽量在第一行，之前不能有任何注释或标签，若浏览器在第一行读取不到文档类型声明时，会认为文档类型声明不存在，导致声明无效（主要是 IE9 或更早期的浏览器）。\n有哪些文档模式 目前浏览器的排版引擎有三种模式：怪异模式、准标准模式以及标准模式。怪异模式下，排版会模拟 Navigator4 和 IE5 的非标准模式行为，怪异模式的影响主要是 CSS 渲染，IE 中会影响 JavaScript 对浏览器窗口宽高值的计算方式。标准模式下，行为即为 HTML 与 CSS 规范描述的行为。在准标准模式下，只有少数的怪异行为被实现。\n计出无奈 网景的 Navigator 和 微软的 IE，由于初期规范的缺乏，两家浏览器按照各自的方式渲染页面。后来，W3C 创立网络标准，浏览器厂商逐渐向标准靠拢，在这个时间节点上，要保证既有网站能正常运行，就不能放弃之前的渲染方式。\n相比 IE5.5，IE6 支持了部分 CSS1 中的特性（典型就是盒模型），导致两者对页面的渲染相去甚远。既要保证既有网站的正常运行，又要保证浏览器能按选择以标准形式渲染页面，浏览器提供了文档类型声明的功能，用以将符合新规范的网站和旧有网站区分。\n浏览器控制台中有选项可查看当前页面模式，也可以通过 document.compatMode 这个早期由微软创造的属性查看，返回一个字符串，有以下两种返回值： - BackCompat：标准兼容模式未开启 - CSS1Compat：标准兼容模式已开启\n要而论之，DOCTYPE 本质来说就是在浏览器向标准逐步靠拢的过程中，为向前兼容而不得不创造的 “开关”。 没有文档声明或使用了能够触发混杂模式的 DOCTYPE，浏览器将以怪异模式渲染；在声明为标准模式时，浏览器便以标准模式渲染（前提是支持标准模式，如 IE5.5 及之前版本的浏览器，均不支持标准模式）。在 HTML5 中，DOCTYPE 的作用（也是唯一作用）就是启用标准模式。\n准标准模式 那么还有一个准标准模式（Almost Standards Mode）是什么呢？主要是体现在对于表格单元格内垂直方向布局渲染差异，由于从 IE8 开始，Firefox、Chrome、Safari、Opera 7.5 开始，这些浏览器的标准模式更加严格的遵守了 CSS2.1 规范，相对如今的标准模式“不太标准”，被赋予“准标准模式”的名字。由于 IE6 诞生时，CSS2.1 规范尚未出台，无法严格遵循 CSS2.1 规范，因此对 IE6、IE7 以及 Opera 7.5 之前版本来说就没有这个准标准模式，也可以认为它们的准标准模式就是标准模式。一般说到标准模式时，指的是除怪异模式之外的其它模式。准标准模式和标准模式在 document.compatMode 的输出均是 CSS1Compat。\n怪异模式的特性 除之前提到的盒模型外，与标准模式相比，怪异模式还有以下特性： - 行框内的图片对齐基线与标准不一致 - table 元素不会继承字体的某些属性，尤其是 font-size 属性 - 内联元素可以定义尺寸 - 溢出内容的 overflow 为 visible 时，会调整父元素的大小以完全包含内容。\n","date":"19","image":"images/head_one.jpg","permalink":"/blog/%E7%AE%80%E8%B0%88%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F/","tags":null,"title":"简谈文档模式"},{"categories":["HTML","ECMAScript"],"contents":" crossorigin 属性 crossorigin 值有 anonymous 和 use-credentials，空值如 crossorigin 或 crossorigin=\u0026ldquo;\u0026rdquo; 缺省为 anonymous，如果未指定此属性，CORS 将不会启用，若启用必须保证服务器已开启跨域请求允许。其他 HTML5 元素如 \u0026lt;audio\u0026gt;、\u0026lt;video\u0026gt;、\u0026lt;link\u0026gt;、\u0026lt;img\u0026gt; 等均有跨域属性。\nanonymous 值表示对此元素的 CORS 请求将不设置凭据标志；use-credentials 表示对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。换句话说，就是 use-credentials 允许浏览器携带 Cookie 等凭证数据到服务器，而 anonymous 不允许。\n请求 CDN 等内容可指定为 anonymous，在获取需要用户凭证的内容如 manifest 时，属性就必须(即使同源也要设置）设置为 use-credentials，Google 搜索首页的案例如下：\n\u0026lt;link href=\u0026#34;/manifest?pwa=webhp\u0026#34; crossorigin=\u0026#34;use-credentials\u0026#34; rel=\u0026#34;manifest\u0026#34;\u0026gt; integrity 属性 integrity 属性的值是经 base64 编码过后的文件哈希值，用于确认脚本或样式表内容未经篡改，防止遭遇 CDN 被入侵或中间人攻击引发的安全问题。integrity 可有多个哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载。在许多 CDN 上，提供了拷贝「HTML + SRI」的功能，就是在引用资源的 integrity 属性上携带了 CDN 服务器生成的哈希值，SRI 即子资源完整性（Subresource Integrity）。\nintegrity 值共两个部分：第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512）；第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。可以通过 openssl 或者 shasum 生成 SRI 哈希值，在服务器或 CDN 中，可强制脚本或样式表必须通过 integrity 携带哈希值检验资源完整性，若未携带或值错误，内容将不会被加载，在安全性要求较高的项目可采取这种方式增加可靠性。实际生成的哈希值如下：\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/lodash@4.17.20/lodash.min.js\u0026#34; integrity=\u0026#34;sha256-ur/YlHMU96MxHEsy3fHGszZHas7NzH4RQlD4tDVvFhw=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; type 属性 type 属性用于代替旧有非标准属性 language，用以表示代码块中脚本语言的 MIME 类型。type 属性支持的 MIME 类型有：text/javascript、text/ecmascript、application/javascript 和 application/ecmascript。HTML5 中的缺省值为 text/javascript。\n若 MIME 类型不是上述支持的类型，则元素所包含内容会被当做数据块而不被执行。当 type 属性值为 module 时，代码会被当做 ES6+ 模块，此时代码中方可出现 import 和 export 关键字。\nnomodule 属性 当浏览器不支持 type=\u0026ldquo;module\u0026rdquo; 时，用 \u0026lt;script nomodule src=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; 将打包的脚本作为备选进行执行，同时在支持 type=\u0026ldquo;module\u0026rdquo; 的浏览器中将不会执行。\nsrc 引用外部脚本文件 引用外部文件被认为是比使用行内代码更佳的做法，理由是引用外部文件，在可维护性，缓存和适应未来等方面有更大的优势。可能是受到曾风靡一时的雪碧图的影响，许多开发人员偏爱将某一页面引用的全部脚本打包成一个脚本文件，用以避免多次创建 HTTP 请求造成的延迟和性能消耗。\n随着曾经 SPDY（speedy，Google 最早提出的通过压缩、多路复用和优先级缩短网页加载时间的协议，15 年 9 月，Google 宣布移除对 SPDY 的支持）的过渡和如今 HTTP/2 的普及，适当拆分既不会降低传输效率，也能最大程度使用浏览器的缓存能力。\nasync 与 defer 属性 当浏览器解析到 \u0026lt;script\u0026gt; 元素时，若没有 async 或是 defer 属性，浏览器将立即下载脚本并执行，下载和执行期间，后续解析被阻塞。\n当 \u0026lt;script\u0026gt; 元素有 async 或 defer 属性时，浏览器将立即下载脚本，后续解析如下： - 当属性为 async 时，脚本下载完后就会停止解析，并立即执行已下载的异步脚本。 - 当属性为 defer 时，脚本下载完成后将等待所有元素解析完成之后，DOMContentLoaded 事件之前完成，若有多个延迟脚本将按顺序执行（高程三、四均表示执行顺序仅理论如此，实际不确定，保证页面至多一个 defer 脚本是最佳实践）。\n当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完全加载。async、defer 和普通渲染流程示意如下：\n动态导入脚本文件 const script = document.createElement(\u0026#39;script\u0026#39;) script.src = \u0026#39;lodash.js\u0026#39; // script.async = false document.head.appendChild(script)  脚本通过上述方式动态加载时，会异步加载，相当于添加了 async 属性。若需按照加载的顺序执行，要将 async 属性设置为 false。\n","date":"26","image":"images/head_two.jpg","permalink":"/blog/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3script%E6%A0%87%E7%AD%BE%E5%90%97/","tags":null,"title":"你真的了解 script 标签吗"},{"categories":["Node.js"],"contents":" npx 是跟随 npm\\@5.2.0 版本一起发布的，安装 5.2.0 版本及之后的 npm ，会自动安装 npx。npx 可以认为是「NPM Package Executor」的缩写，它为 npm 包管理和执行提供辅助功能。\n查看 npx 版本：\nnpx --version 如果 npm 版本低于 5.2.0 ，可以升级 npm 版本，或全局安装以使用 npx：\nnpm install -g npx 调用项目安装的模块 如果项目中安装了可执行的模块，在 node_modules/.bin 目录下会有相应的指令用于执行。例如，使用 Next.js 构建的项目在 node_modules/.bin 下会有 next 命令，可以通过以下方式调用：\n命令行调用：\nnode node_modules/.bin/next -v npx 调用：\nnpx next -v npx 会自动在 node_modules/.bin 路径和环境变量 $PATH 进行执行文件定位，如果查找成功，直接执行。如果查找失败，会临时下载对应模块的运行程序到一个临时目录，使用以后再删除，以后再次执行相同的命令，会重新下载。\n运行 npx ls，由于环境变量中有 ls 命令，因此会立即执行：\n避免全局安装模块 npx 可以避免全局安装模块，例如在某个目录下需要启动 web 服务，可以使用 npx 运行包 http-server：\nnpx http-server 执行成功后，http-server 默认代理执行命令所在路径下的文件。退出执行，http-server 会被自动清除，下次运行时会重新下载并执行。\n前端的 CLI 工具如 create-react-app 和 vue-cli 等，在生成模板项目时，不再需要卸载旧版本的全局包，再安装最新版本：\nnpx create-react-app demo npx -p @vue/cli vue create demo 执行远程模块 npx 可以从 URL 执行程序包，前提是 URL 上的远程代码必须是一个规范的 Node.js 模块，即必须包含 package.json 文件和入口脚本，并确认模块安全。比如用 Github Gist 存放的 Node.js 脚本，可以用 npx 执行，Github Gist 中的内容：\n本地执行如下 :\n切换 Node.js 版本 利用 npx 可以下载模块的特点，可以指定具体版本的 Node.js 运行脚本：\nnpx node@0.12.8 -v 上面命令会使用 0.12.8 版本的 Node.js 执行，利用 npm 下载这个版本的 Node.js，使用后再删除。某些场景下，这种切换 Node.js 版本的方式相对简洁。\n常用参数 --no-install 如果想让 npx 强制使用本地模块，不下载远程模块，可以添加 \u0026ndash;no-install 参数。如果本地不存在该模块，就会报错。\nnpx --no-install http-server --ignore-existing 反过来，如果要忽略本地的同名模块，强制安装使用远程模块，可以使用 \u0026ndash;ignore-existing 参数。比如，本地已经全局安装了 create-react-app，但还是想使用远程模块，就可以使用这个参数。\nnpx --ignore-existing create-react-app react-app -p -p 参数用于指定 npx 所要安装的模块，并添加到正在运行的环境变量 $PATH。 所以之前切换 Node.js 版本的命令可以写成下面这样。\nnpx -p node@0.12.8 node -v  最后 npx 是用于执行 npm 包（包括 npm 官方包或符合规范的远程模块）的工具，使开发者使用 CLI 工具和被托管的可执行文件更方便，让交互式调用本地二进制文件更自由，提升了项目开发管理的效率。\n","date":"13","image":"images/head_three.jpg","permalink":"/blog/%E7%89%A9%E5%B0%BD%E5%85%B6%E7%94%A8npx/","tags":null,"title":"物尽其用「npx」"},{"categories":["DevOps"],"contents":" 本文介绍在 Ubuntu 20.04 系统中搭建 PHP、 MySQL 和 Nginx 集成环境，在此基础上安装 Typecho 并获取 HTTPS 认证。\n首先，通过包管理器更新源并升级软件：\nsudo apt-get update sudo apt-get upgrade 安装 PHP 和相关扩展 数据库使用 MySQL，需要在 PHP 中安装扩展 php-mysql。与 Apache 不同，Nginx 没有内置对 PHP 文件的处理支持，因此需要使用 php-fpm 来处理 PHP 文件。\nsudo apt-get -y install php php-mysql php-fpm 注意，在执行上面的命令后，系统会自动安装 Apache2，将其卸载：\nsudo apt-get --purge remove apache2 安装配置 MySQL sudo apt-get -y install mysql-server 执行 sudo cat /etc/mysql/debian.cnf 查看数据库初始化配置，找到 user 和 password 字段：\n为方便后续配置和使用 MySQL，使用密码登录 MySQL 后配置 root 用户密码：\nmysql -u debian-sys-maint -p 输入密码回车完成 MySQL 认证，接着在 MySQL 交互命令行中操作：\nuse mysql; -- 设置 MySQL 数据库 root 用户的密码 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;自定义 root 用户密码\u0026#39;; flush privileges; exit 执行 mysql -u root -p ，输入刚才设置的新密码进行登录，登录后创建名为 typecho 数据库：\nCREATE DATABASE typecho DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci; 安装配置 Nginx sudo apt-get -y install nginx 安装 Nginx 后，在浏览器通过 IP 地址访问服务器，可以看到「Welcome to nginx!」的欢迎页面，表明 Nginx 已成功安装并启动。将域名解析到服务器 IP 地址，然后修改 Nginx 配置：\nsudo vi /etc/nginx/sites-enabled/default 配置 Nginx 基本内容：\nserver { server_name soupcraft.icu, www.soupcraft.icu; listen 80; root /var/www/html; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { include fastcgi.conf; include fastcgi_params; fastcgi_pass unix:/run/php/php7.4-fpm.sock; } } 保存文件后，执行 sudo service nginx restart 重启 Nginx，即可通过域名访问。\n安装 Typecho 首先移动到之前 Nginx 配置的 root 属性路径下（root 属性可配置其它路径，保持一致即可）：\ncd /var/www/html 复制 Typecho 的下载页面正式版的链接地址，在服务器进行压缩包下载并解压：\nsudo wget http://typecho.org/downloads/1.1-17.10.30-release.tar.gz sudo tar -zxvf 1.1-17.10.30-release.tar.gz 移动解压后的文件到 /var/www/html 路径下，并删除无关内容：\nmv build/* ./ rm -r build rm 1.1-17.10.30-release.tar.gz 通过域名进入网站 /install.php 页面，填写数据库配置、网站和个人信息，提交后，出现以下页面：\n复制框中的数据库配置内容，按照提示粘贴保存至 config.inc.php 文件中：\ncd /var/www/html sudo vi config.inc.php 保存退出后，切回浏览器点击「创建完毕，继续安装」按钮，完成后续安装。\n权限 在安装和后续使用过程中，可能会多次出现对某个目录没有写入权限的问题：比如在管理外观时出现「此文件无法写入」的提示；scp 上传文件、插件或主题时被告知「Permission denied」等。使用 chmod 命令修改权限即可解决：\nsudo chmod -R 777 /var/www/html/usr/ 使用 Certbot 获取 SSL 证书 腾讯云的免费 SSL 证书申请始终处于验证状态，方便起见，用 Certbot 获取证书，选择服务软件为 Nginx，选择操作系统为 Ubuntu 20.04 之后，会自动跳转安装页面，按照文档流程在服务器进行操作，由于 Ubuntu 20.04 已经预安装了 snapd，直接开始以下步骤：\nsudo snap install --classic certbot sudo certbot --nginx 自动更新配置后，稍加修改，完整的 /etc/nginx/sites-enabled/default 文件配置内容如下：\nserver { server_name soupcraft.icu, www.soupcraft.icu; listen 80; return 301 https://www.soupcraft.icu$request_uri; } server { server_name www.soupcraft.icu; root /var/www/html; index index.php; location / { try_files $uri $uri/ /index.php$is_args$args; } location ~ \\.php$ { include fastcgi.conf; include fastcgi_params; fastcgi_pass unix:/run/php/php7.4-fpm.sock; } listen 443 ssl; # managed by Certbot  ssl_certificate /etc/letsencrypt/live/www.soupcraft.icu/fullchain.pem; # managed by Certbot  ssl_certificate_key /etc/letsencrypt/live/www.soupcraft.icu/privkey.pem; # managed by Certbot  include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot  ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot } 打开 80 端口的域名，会被重定向到 443 端口，安装完成~\n","date":"12","image":"images/head_four.jpg","permalink":"/blog/ubuntu-20.04-%E5%AE%89%E8%A3%85-typecho-%E5%B9%B6%E5%AE%8C%E6%88%90-https-%E8%AE%A4%E8%AF%81/","tags":null,"title":"Ubuntu 20.04 安装 Typecho 并完成 HTTPS 认证"}]