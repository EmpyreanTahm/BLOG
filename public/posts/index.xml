<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on GeekKery</title>
    <link>https://geekkery.4everland.app/posts/</link>
    <description>Recent content in Posts on GeekKery</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>GeekKery</copyright>
    <lastBuildDate>Wed, 04 May 2022 18:07:18 +0800</lastBuildDate><atom:link href="https://geekkery.4everland.app/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>代码回滚的两种模式</title>
      <link>https://geekkery.4everland.app/posts/%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 04 May 2022 18:07:18 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F/</guid>
      <description>职业生涯以来，少有项目版本需要回滚的情况。回滚操作时，无暇截图，今简要记录。
提交记录 1 2 3 4 5  git log --oneline # Oh My Zsh glo glol   查看提交记录，获取需要回滚的版本对应的 &amp;lt;commit ID&amp;gt;。
reset 1 2 3 4  # unstage all and rollback git reset --hard &amp;lt;commit ID&amp;gt; # push git push -f origin &amp;lt;branch&amp;gt;   reset 命令的问题在于：push 远程后，其他开发人员本地会被告知版本领先，如果这些发开人员习惯性地 push 本地领先版本，就会造成回滚的撤销。这种回滚代码的形式，需要在回滚后通知其他开发人员，注意丢弃某些版本的代码，避免造成困惑。
换句话说，reset 回滚需要当前分支的所有开发人员一起执行回滚。
事实上，reset 命令并非用于已 push 的代码回滚，而是主要用于本地未 push 的代码回滚。
reset 记录模型 1 2 3 4 5 6 7 8  # 回滚前 .</description>
    </item>
    
    <item>
      <title>可选链和双问号</title>
      <link>https://geekkery.4everland.app/posts/%E5%8F%AF%E9%80%89%E9%93%BE%E5%92%8C%E5%8F%8C%E9%97%AE%E5%8F%B7/</link>
      <pubDate>Mon, 18 Apr 2022 21:17:03 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E5%8F%AF%E9%80%89%E9%93%BE%E5%92%8C%E5%8F%8C%E9%97%AE%E5%8F%B7/</guid>
      <description>可选链 ?. 访问多层对象属性时，若其中某个对象类型错误，将导致引用错误。在已约定好类型的情况下，为获取正确的 petitioners[0].address.street.number，需对整个链路进行校验：
1 2  const petitioners = [] const num = petitioners &amp;amp;&amp;amp; petitioners[0] &amp;amp;&amp;amp; petitioners[0].address &amp;amp;&amp;amp; petitioners[0].address.street &amp;amp;&amp;amp; petitioners[0].address.street.number   可选链写法：
1 2  const petitioners = [] const num = petitioners?.[0]?.address?.street?.number // undefined，不报错   可选链操作符 ?. 允许读取位于连接对象（包括数组类型）链深处的属性的值，而不必明确验证链中的每个引用是否有效。在引用为 null 或 undefined 的情况下不会引起错误，该表达式短路返回值是 undefined。与函数调用一起使用时，如果给定的函数不存在返回 undefined，而不是抛出异常。
1  petitioner.applyForGreenCard?.() // undefined，不报错   双问号 ?? 空值合并操作符 ?? 是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。
逻辑或操作符 || 会在左侧操作数为假值时返回右侧操作数。也就是说，|| 计算值时，左侧值会进行隐式类型转换成布尔值，比如 0， &amp;lsquo;&#39;， NaN， null， undefined 等都会返回右侧值。</description>
    </item>
    
    <item>
      <title>Oh My Zsh 常用 Git 命令</title>
      <link>https://geekkery.4everland.app/posts/ohmyzsh%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 17 Apr 2022 18:33:03 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/ohmyzsh%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4/</guid>
      <description>基本概念  工作区（workspace）：就是你在电脑里能看到的目录； 暂存区（staging area）：存放在 .git/index 文件中，有时也把暂存区叫作索引； 版本库（local repository）：工作区有一个隐藏目录 .git，这就是 Git 版本库； 远程仓库（remote repository）：本地版本库对应的远程仓库。  Git 基本信息配置 1 2 3 4 5 6 7 8 9 10 11  # 全局配置；只修改当前项目去掉 --global 参数 git config --global user.name &amp;#34;Jayden Deng&amp;#34; git config --global user.email &amp;#34;jayden@gmail.com&amp;#34; # 编辑配置文件 git config -e # 针对当前仓库  git config -e --global # 针对系统上所有仓库 # 查看配置 gcf = &amp;#39;git config --list&amp;#39; # 查看所有配置 git config user.name # 查看特定项配置   状态查询 1 2 3 4 5 6 7 8  gss = &amp;#39;git status -s&amp;#39; # 简短模式 gsb = &amp;#39;git status -sb&amp;#39; # 简短模式 + 分支 gd = &amp;#39;git diff&amp;#39; # 工作区与暂存区差异 gdca = &amp;#39;git diff --cached&amp;#39; # 已暂存文件和上次提交时的快照之间的差异 glo = &amp;#39;git log --oneline --decorate&amp;#39; # 单行提交信息查看提交记录 glol = &amp;#34;git log --graph --pretty=&amp;#39;&amp;#39;&amp;#34; # 全方位查看提交记录   工作区 =&amp;gt; 版本库 注意，Git2.</description>
    </item>
    
    <item>
      <title>Composition API</title>
      <link>https://geekkery.4everland.app/posts/composition-api/</link>
      <pubDate>Sun, 10 Apr 2022 17:00:51 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/composition-api/</guid>
      <description>Vue3 中的更新内容不少，Composition API 是最吸引人的功能。
某个视图包含多个功能：获取列表数据、搜索和筛选过滤等。Vue3 之前的 Options API 注定同一功能的 props、data、computed、watch 和 methods 等相关属性和方法被隔离开来，功能越繁多，碎片化越严重。为开发或修改某一功能，需要在 Vue 实例的 options 之间频繁切换。
现在，通过 Composition API 可将组件中某一功能的 props、data、computed、watch 和 methods 等相关属性和方法进行聚合，避免碎片化。
setup Vue 实例新增 setup(props,context) 函数属性，在组件被创建之前执行，props 被解析完成，setup 就被作为 Composition API 的入口。
setup 的执行时机为 beforeCreate 钩子之前，无法通过 this 访问 Vue 实例。
props 参数 props 为接收属性，使用 ES6 解构会消除 props 的响应式。若需解构 props，在 setup 函数中使用 toRefs 函数：
1 2 3 4 5  import { toRefs } from &amp;#39;vue&amp;#39; setup(props) { const { title } = toRefs(props) console.</description>
    </item>
    
    <item>
      <title>算法解析</title>
      <link>https://geekkery.4everland.app/posts/%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 05 Apr 2021 18:13:23 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/</guid>
      <description>两数之和（简单） 题目描述 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
1 2 3  输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。   示例 2：
1 2  输入：nums = [3,2,4], target = 6 输出：[1,2]   示例 3：
1 2  输入：nums = [3,3], target = 6 输出：[0,1]   解答 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  /** * @param {number[]} nums * @param {number} target * @return {number[]} */ // 双层 for 循环 const twoSum = function (nums, target) { for (let i = 0, len = nums.</description>
    </item>
    
    <item>
      <title>原型与继承</title>
      <link>https://geekkery.4everland.app/posts/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</link>
      <pubDate>Fri, 26 Feb 2021 19:01:09 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E7%BB%A7%E6%89%BF/</guid>
      <description>面向对象 在 JavaScript 中，“朴素”的对象指的是字面量 {} 和 new Object() 构造出的对象：
1 2  var obj1 = {prop1: &amp;#39;value1&amp;#39;} var obj2 = new Object({prop2: &amp;#39;value2&amp;#39;})   实际上，对象只是一种拥有属性和方法的特殊数据。JavaScript 中的所有事务都是对象：字符串、数值、数组、函数等。所有对象都是 Object 类型的实例。在讨论原型时，需要认识到函数是对象。
__proto__、prototype 和 constructor 原型基本准则：
 __proto__ 属性：所有对象拥有，指向其构造函数的原型； prototype 属性：只有函数对象拥有，指向（构造）函数的原型； 原型是对象类型，同样拥有 __proto__ 属性指向原型的原型； 原型的 constructor 属性指向构造函数本身。  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  function Person(name) { this.</description>
    </item>
    
    <item>
      <title>浅谈 GC</title>
      <link>https://geekkery.4everland.app/posts/%E6%B5%85%E8%B0%88-gc/</link>
      <pubDate>Fri, 19 Feb 2021 15:04:44 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E6%B5%85%E8%B0%88-gc/</guid>
      <description>内存的生命周期包括分配内存、使用内存和释放内存。有些语言（比如 C 语言）必须手动分配和释放内存，JavaScript 的内存分配过程是在做变量声明赋值时自动完成的。变量完成内存分配之后程序才可以使用进行读写。当程序不需要再使用某些变量时，它们占用的内存就会进行释放，腾出空间。
内存溢出 程序的运行需要内存，只要程序提出要求，操作系统或者运行时（Runtime）就必须供给内存。程序运行过程中申请的内存大于系统能够提供的内存，导致程序无法申请到足够的内存，这就是内存溢出（Out Of Memory）。
内存泄漏 不再用到的内存，没有及时释放，就叫做内存泄漏（Memory Leak），内存泄漏与大小无关，并非导致程序卡顿、崩溃才能叫做内存泄漏。
内存泄漏的堆积，会使内存占用越来越高，轻则影响系统性能，重则导致进程崩溃，尤其是持续运行的服务进程（Daemon）。
在 Chrome 浏览器的 Performance 功能中，使用 Memory 选项可以帮助开发者查看内存占用，如果内存不是趋于平稳，而是一直上升，则可能发生了内存泄漏。在 Performance 功能中，也可以手动进行垃圾回收。
Node.js 提供了 process.memoryUsage 方法，process.memoryUsage 返回一个对象，包含了 Node.js 进程的内存占用信息，该对象包含四个字段，单位是字节。判断内存泄漏，以 heapUsed 字段为准。
1 2 3 4 5 6 7 8 9  console.log(process.memoryUsage()) // Prints: // { // rss: 4935680, // heapTotal: 1826816, // heapUsed: 650472, // external: 49879, // arrayBuffers: 9386 // }     rss（resident set size）：所有内存占用，包括指令区和堆栈； heapTotal：”堆“占用的内存，包括用到的和没用到的； heapUsed：用到的堆的部分； external： V8 引擎内部的 C++ 对象占用的内存； arrayBuffers：分配给 ArrayBuffers 和 SharedArrayBuffers 的内存，包括所有 Node.</description>
    </item>
    
    <item>
      <title>this 机制</title>
      <link>https://geekkery.4everland.app/posts/this-%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Tue, 19 Jan 2021 18:03:44 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/this-%E6%9C%BA%E5%88%B6/</guid>
      <description>关于 this 如果对于有经验的 JavaScript 开发者来说，this 都是一种非常复杂的机制，那它到底有用在哪里呢？下面来解释一下为什么要使用 this：
1 2 3 4 5 6 7 8 9 10 11 12  function identify() { return this.name.toUpperCase(); } var me = { name: &amp;#34;Kyle&amp;#34; }; var you = { name: &amp;#34;Reader&amp;#34; }; identify.call(me); // Kyle identify.call(you); // Reader   这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify，不用针对每个对象编写不同版本的函数。如果不使用 this，那就需要给 identify 显式传入一个上下文对象。
1 2 3 4 5 6 7 8 9 10 11 12  function identify(context) { return context.</description>
    </item>
    
    <item>
      <title>作用域和闭包</title>
      <link>https://geekkery.4everland.app/posts/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</link>
      <pubDate>Mon, 18 Jan 2021 15:03:44 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/</guid>
      <description>词法作用域 作用域是一套规则，这套规则用来管理引擎如何在当前的作用域以及嵌套的子作用域中根据标识符名称进行变量查找。作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫做动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式等）。JavaScript 中的作用域就是词法作用域。
词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。
欺骗词法 如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”（即欺骗）词法作用域呢？
JavaScript 中有两种机制来实现这个目的：eval(..) 函数和 with 关键字。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。
这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎地认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。避免使用它们。
动态作用域 动态作用域并不关心函数和作用域是如何声明以及在何处声明的，只关心它们从何处调用。换句话说，作用域链是基于调用栈的，而不是代码中的作用域嵌套。
因此，如果 JavaScript 具有动态作用域，理论上，下面代码中的 foo() 在执行时将会输出 3。
1 2 3 4 5 6 7 8 9  function foo() { console.log(a) // 3(不是 2 !) } function bar() { var a = 3 foo() } var a = 2 bar()   为什么会这样？因为当 foo() 无法找到 a 的变量引用时，会顺着调用栈在调用 foo() 的地方查找 a，而不是在嵌套的词法作用域链中向上查找。由于 foo() 是在 bar() 中调用的，引擎会检查 bar() 的作用域，并在其中找到值为 3 的变量 a。</description>
    </item>
    
    <item>
      <title>浅析 HTTPS</title>
      <link>https://geekkery.4everland.app/posts/%E6%B5%85%E6%9E%90-https/</link>
      <pubDate>Fri, 15 Jan 2021 20:14:56 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E6%B5%85%E6%9E%90-https/</guid>
      <description>HTTP 的缺点 HTTP 具有相当优秀的和方便的一面，简单、灵活、易于扩展是它显著的特点。然而 HTTP 并非只有好的一面，事物皆具有两面性，它也有不足之处。
明文通信 HTTP 本身不具备加密的功能，无法做到对通信整体进行加密。按 TCP/IP 协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包，然后使用抓包或嗅探器工具对收集来的数据包进行解析即可。
不验证通信方的身份 HTTP 协议中的请求和响应不会对通信方进行确认，任何人都可以发起请求。服务器只要接收到请求，并且发送端的 IP 地址和端口号没有被 Web 服务器设定限制访问，不管对方是谁都会返回一个响应，这样会存在以下隐患：无法确定请求的目标服务器是否是按真实意图返回响应的那台服务器，有可能是已伪装的 Web 服务器；无法确定响应返回的客户端是否是按真实意图接收响应的那个客户端，有可能是已伪装的客户端；无法确定正在通信的对方是否具备访问权限；无法判定请求是来自何方、出自谁手；即使是无意义的请求也会照单全收，无法阻止海量请求下的 DoS 攻击。
无法证明报文完整性 完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。HTTP 协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，如果请求或响应遭到篡改，也没有办法获悉。
HTTPS 是什么 HTTPS（HTTP Secure）并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL（Secure Socket Layer） 或 TLS（Transport Layer Security）协议代替而已。当使用 SSL/TLS 时，HTTP 先和 SSL/TLS 通信，再由 SSL/TLS 和 TCP 通信。在采用 SSL/TLS 后，HTTP 就拥有了 HTTPS 的加密、认证和完整性保护这些功能。
SSL 技术最初是由网景公司率先倡导的，开发过 SSL3.0 之前的版本，目前主导权已转移到 IETF（Internet Engineering Task Force，Internet 工程任务组）的手中。IETF 以 SSL3.0 为基准，后又制定了 TLS1.0、TLS1.1 和 TLS1.2。TLS 是以 SSL 为原型开发的协议，有时会统一称该协议为 SSL。当前的主流协议是 SSL3.</description>
    </item>
    
    <item>
      <title>HTTP 缓存机制</title>
      <link>https://geekkery.4everland.app/posts/http-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sat, 09 Jan 2021 12:26:02 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/http-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>HTTP 缓存通过资源复用，可以减轻服务器负担，显著提高网站和应用程序的性能。HTTP 缓存主要有客户端缓存和代理缓存，其它还包括网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式。HTTP 缓存主要存储 GET 响应。
以 Chrome 为例，打开新标签页后调出 DevTools，将功能切至 NetWork，首次访问 Google 搜索页面，能看到请求：
ctrl + r 刷新页面，可看到请求：
在 Size 一栏中，可以看到部分资源来自 Memory Cache，部分来自 Disk Cache，其余从服务器获取。在首次访问页面之后，浏览器会将资源缓存，后续访问这些资源时，可直接从缓存中获取，不必再从服务器下载。
根据是否需要重新向服务器发起请求来分类，可以将 HTTP 缓存分为两类：强缓存和协商缓存。强缓存如果生效，不需要再和服务器发生交互，而协商缓存不管是否生效，都需要与服务端发生交互。强缓存的优先级高于协商缓存。
强缓存 强缓存指首次向服务器发起资源请求后，服务器会告知客户端资源缓存的有效时间，有效期内直接从客户端缓存中读取，不必与服务器交互。强缓存通过 Expires 和 Cache-Control 首部字段来实现，后者优先级更高。
Expires HTTP/1.0 定义了 Expires 响应首部字段，用于告知客户端资源缓存的过期时间，在过期时间之前请求资源直接使用缓存，不需要再次请求服务器（排除其它首部字段干扰的情况下）。
1  Expires: Mon, 25 Jan 2021 23:04:06 GMT   Expires 过期时间由服务器生成，是否过期的判定最终需要参考客户端时间。客户端和服务器时间可能不一致，而且客户端的时间是可以自行修改的，修改客户端时间可能导致缓存失效（如浏览器时间参考操作系统时间，修改系统时间会影响到缓存），所以不一定满足预期。
Cache-Control 为弥补 Expires 的缺点，HTTP/1.1 新增了 Cache-Control 通用首部字段，时间值为相对时间，且不依赖客户端时间，优先级高于 Expires。
   指令 类型 说明     no-cache 通用 资源正常缓存，但使用前必须进行协商校验   no-store 通用 禁用所有缓存，从源服务器获取资源   public 响应 共享缓存（中间代理和 CDN等）和私有缓存（客户端）都可以缓存响应，缺省值为 private   private 响应 只有私有缓存可以缓存响应   max-age = N 响应 缓存有效期（单位秒），为 0 时与 no-cache 效果一致   s-maxage = N 响应 覆盖 max-age，只适用于共享缓存，私有缓存会忽略   must-revalidation 响应 在缓存过期前可以使用，过期（如缓存时间超过 max-age）后必须向服务器验证   proxy-revalidation 响应 与 must-revalidate 作用相同，但仅适用于共享缓存，私有缓存会忽略。   no-transform 通用 代理不可更改媒体类型如 Content-Encoding、Content-Range、Content-Type    对于那些改动频率极低的资源如 CSS 或 JS 库，常见的做法是将 max-age 的值设为 31536000，代表一年内缓存有效。如果在缓存有效期内，内容资源内容发生了改动，可以修改资源名称，如在资源名称中加版本号或生成随机 hash。</description>
    </item>
    
    <item>
      <title>常用的一些命令行</title>
      <link>https://geekkery.4everland.app/posts/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%A1%8C/</link>
      <pubDate>Tue, 05 Jan 2021 04:12:59 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E8%A1%8C/</guid>
      <description>grep 查找搜索 1 2  # 查找 src 目录及其所有子目录下的 target.pidNumber 文本 grep -r target.pidNumber src   Mac OS 持久化别名指定 在终端中执行的 alias 命令指定的别名仅本次登录有效，若需使别名永久生效，可以执行 vi ~/.bashrc，在文件末尾中添加行：
1  ub2=&amp;#39;ssh ubuntu@139.155.86.169&amp;#39;   保存退出后，使用 source 命令刷新环境变量后即可使用自定义的 ub2 命令：
1  source ~/.bashrc   如果系统使用的是 zsh，编辑配置 ~/.zshrc 即可，终端执行 echo $0 可查看当前使用的 shell 类型。
Linux 拷贝命令 cp、rcp 和 scp cp Linux cp 命令语法：
1 2 3  cp [options] source destination cp [options] source.</description>
    </item>
    
    <item>
      <title>叹流年</title>
      <link>https://geekkery.4everland.app/posts/%E5%8F%B9%E6%B5%81%E5%B9%B4/</link>
      <pubDate>Fri, 01 Jan 2021 04:06:39 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E5%8F%B9%E6%B5%81%E5%B9%B4/</guid>
      <description>2021 年 1 月 1 日 昨日夜，辗转反侧，难以入眠，遂相邀叙旧，与约酒肆。唯李兄至。恰新旧交替，聚者甚多，宾客盈门，不逢时，门口落座，饮至翌年，谈古说今，甚欢。
酒后难舍，蓉城街头，阔步高谈，行至天明。东谈西说，过眼云烟，唯二三事，言犹在耳。
卜数只偶，故地重游。负笈求学，于兹三载，东劳西燕，距此又两年有余。昔日同窗，各自文采风流，为余所钦，今关山阻隔，天涯沦落，忾然叹息。
 残腊即又尽，东风应渐闻。
一宵犹几许，两岁欲平分。
燎暗倾时斗，春通绽处芬。
明朝遥捧酒，先合祝尧君。
 </description>
    </item>
    
    <item>
      <title>简谈文档模式</title>
      <link>https://geekkery.4everland.app/posts/%E7%AE%80%E8%B0%88%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 19 Dec 2020 04:01:18 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E7%AE%80%E8%B0%88%E6%96%87%E6%A1%A3%E6%A8%A1%E5%BC%8F/</guid>
      <description>HTML5 文档的第一行就是 &amp;lt;!DOCTYPE html&amp;gt; 用于文档声明。首先，这不是 HTML 标签，DOCTYPE 意为文档类型，这段代码用于文档类型声明。其次，文档类型声明应尽量在第一行，之前不能有任何注释或标签，若浏览器在第一行读取不到文档类型声明时，会认为文档类型声明不存在，导致声明无效（主要是 IE9 或更早期的浏览器）。
有哪些文档模式 目前浏览器的排版引擎有三种模式：怪异模式、准标准模式以及标准模式。怪异模式下，排版会模拟 Navigator4 和 IE5 的非标准模式行为，怪异模式的影响主要是 CSS 渲染，IE 中会影响 JavaScript 对浏览器窗口宽高值的计算方式。标准模式下，行为即为 HTML 与 CSS 规范描述的行为。在准标准模式下，只有少数的怪异行为被实现。
计出无奈 网景的 Navigator 和 微软的 IE，由于初期规范的缺乏，两家浏览器按照各自的方式渲染页面。后来，W3C 创立网络标准，浏览器厂商逐渐向标准靠拢，在这个时间节点上，要保证既有网站能正常运行，就不能放弃之前的渲染方式。
相比 IE5.5，IE6 支持了部分 CSS1 中的特性（典型就是盒模型），导致两者对页面的渲染相去甚远。既要保证既有网站的正常运行，又要保证浏览器能按选择以标准形式渲染页面，浏览器提供了文档类型声明的功能，用以将符合新规范的网站和旧有网站区分。
浏览器控制台中有选项可查看当前页面模式，也可以通过 document.compatMode 这个早期由微软创造的属性查看，返回一个字符串，有以下两种返回值：
 BackCompat：标准兼容模式未开启 CSS1Compat：标准兼容模式已开启  要而论之，DOCTYPE 本质来说就是在浏览器向标准逐步靠拢的过程中，为向前兼容而不得不创造的 “开关”。 没有文档声明或使用了能够触发混杂模式的 DOCTYPE，浏览器将以怪异模式渲染；在声明为标准模式时，浏览器便以标准模式渲染（前提是支持标准模式，如 IE5.5 及之前版本的浏览器，均不支持标准模式）。在 HTML5 中，DOCTYPE 的作用（也是唯一作用）就是启用标准模式。
准标准模式 那么还有一个准标准模式（Almost Standards Mode）是什么呢？主要是体现在对于表格单元格内垂直方向布局渲染差异，由于从 IE8 开始，Firefox、Chrome、Safari、Opera 7.5 开始，这些浏览器的标准模式更加严格的遵守了 CSS2.1 规范，相对如今的标准模式“不太标准”，被赋予“准标准模式”的名字。由于 IE6 诞生时，CSS2.1 规范尚未出台，无法严格遵循 CSS2.1 规范，因此对 IE6、IE7 以及 Opera 7.</description>
    </item>
    
    <item>
      <title>&lt;script&gt; 标签</title>
      <link>https://geekkery.4everland.app/posts/script-%E6%A0%87%E7%AD%BE/</link>
      <pubDate>Fri, 26 Jun 2020 03:35:39 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/script-%E6%A0%87%E7%AD%BE/</guid>
      <description>crossorigin 属性 crossorigin 值有 anonymous 和 use-credentials，空值如 crossorigin 或 crossorigin=&amp;quot;&amp;quot; 缺省为 anonymous，如果未指定此属性，CORS 将不会启用，若启用必须保证服务器已开启跨域请求允许。其他 HTML5 元素如 &amp;lt;audio&amp;gt;、&amp;lt;video&amp;gt;、&amp;lt;link&amp;gt;、&amp;lt;img&amp;gt; 等均有跨域属性。
anonymous 值表示对此元素的 CORS 请求将不设置凭据标志；use-credentials 表示对此元素的 CORS 请求将设置凭证标志，这意味着请求将提供凭据。换句话说，就是 use-credentials 允许浏览器携带 Cookie 等凭证数据到服务器，而 anonymous 不允许。
请求 CDN 等内容可指定为 anonymous，在获取需要用户凭证的内容如 manifest 时，属性就必须(即使同源也要设置）设置为 use-credentials，Google 搜索首页的案例如下：
1  &amp;lt;link href=&amp;#34;/manifest?pwa=webhp&amp;#34; crossorigin=&amp;#34;use-credentials&amp;#34; rel=&amp;#34;manifest&amp;#34;&amp;gt;   integrity 属性 integrity 属性的值是经 base64 编码过后的文件哈希值，用于确认脚本或样式表内容未经篡改，防止遭遇 CDN 被入侵或中间人攻击引发的安全问题。integrity 可有多个哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载。在许多 CDN 上，提供了拷贝「HTML + SRI」的功能，就是在引用资源的 integrity 属性上携带了 CDN 服务器生成的哈希值，SRI 即子资源完整性（Subresource Integrity）。
integrity 值共两个部分：第一部分指定哈希值的生成算法（目前支持 sha256、sha384 及 sha512）；第二部分是经过 base64 编码的实际哈希值，两者之间通过一个短横（-）分割。可以通过 openssl 或者 shasum 生成 SRI 哈希值，在服务器或 CDN 中，可强制脚本或样式表必须通过 integrity 携带哈希值检验资源完整性，若未携带或值错误，内容将不会被加载，在安全性要求较高的项目可采取这种方式增加可靠性。实际生成的哈希值如下：</description>
    </item>
    
    <item>
      <title>物尽其用「npx」</title>
      <link>https://geekkery.4everland.app/posts/%E7%89%A9%E5%B0%BD%E5%85%B6%E7%94%A8npx/</link>
      <pubDate>Wed, 13 May 2020 02:12:21 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/%E7%89%A9%E5%B0%BD%E5%85%B6%E7%94%A8npx/</guid>
      <description>npx 是跟随 npm@5.2.0 版本一起发布的，安装 5.2.0 版本及之后的 npm ，会自动安装 npx。npx 可以认为是「NPM Package Executor」的缩写，它为 npm 包管理和执行提供辅助功能。
查看 npx 版本：
1  npx --version   如果 npm 版本低于 5.2.0 ，可以使用 n 模块升级 Node.js 版本，或全局安装以使用 npx：
1  npm install -g npx   调用项目安装的模块 如果项目中安装了可执行的模块，在 node_modules/.bin 目录下会有相应的指令用于执行。例如，使用 Next.js 构建的项目在 node_modules/.bin 下会有 next 命令，可以通过以下方式调用：
命令行调用：
1  node node_modules/.bin/next -v   npx 调用：
1  npx next -v   npx 会自动在 node_modules/.</description>
    </item>
    
    <item>
      <title>Ubuntu20.04 安装 Typecho (附 HTTPS 认证)</title>
      <link>https://geekkery.4everland.app/posts/ubuntu20.04-%E5%AE%89%E8%A3%85-typecho-%E9%99%84-https-%E8%AE%A4%E8%AF%81/</link>
      <pubDate>Tue, 12 May 2020 10:26:06 +0800</pubDate>
      
      <guid>https://geekkery.4everland.app/posts/ubuntu20.04-%E5%AE%89%E8%A3%85-typecho-%E9%99%84-https-%E8%AE%A4%E8%AF%81/</guid>
      <description>本文介绍在 Ubuntu20.04 系统中搭建 PHP、 MySQL 和 Nginx 集成环境，在此基础上安装 Typecho 并获取 HTTPS 认证。
首先，通过包管理器更新源并升级软件：
1 2  sudo apt-get update sudo apt-get upgrade   安装 PHP 和相关扩展 数据库使用 MySQL，需要在 PHP 中安装扩展 php-mysql。与 Apache 不同，Nginx 没有内置对 PHP 文件的处理支持，因此需要使用 php-fpm 来处理 PHP 文件。
1  sudo apt-get -y install php php-mysql php-fpm   注意，在执行上面的命令后，系统会自动安装 Apache2，将其卸载：
1  sudo apt-get --purge remove apache2   安装配置 MySQL 1  sudo apt-get -y install mysql-server   执行 sudo cat /etc/mysql/debian.</description>
    </item>
    
  </channel>
</rss>
