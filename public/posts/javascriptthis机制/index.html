<!DOCTYPE html>
<html lang="en-US">
<head>
  <meta charset="utf-8">
  <title>JavaScript：this机制</title>

  <meta name="author" content="GeeKery">
  <meta name="description" content="  朝闻道 夕死可矣  ">

  <!-- mobile responsive meta -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">

  <!-- Favicon -->
  <link rel="icon" href="/images/favicon.ico" type="image/x-icon">

  <!-- CSS Plugins -->

<link rel="preconnect" href="https://fonts.gstatic.com">











<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Mulish:wght@500;600;700;800;900&amp;display=swap">




<link rel="stylesheet" href="/css/vendor.min.baf52ea3605b317bff1a5643db187b2f7d588fa8f7f86f8563edd75fe058becd61ff13627cd610439cfd7bdb239855cd89ef10674abb20fe6843b2b2aa589c6b.css" integrity="sha512-uvUuo2BbMXv/GlZD2xh7L31Yj6j3&#43;G&#43;FY&#43;3XX&#43;BYvs1h/xNifNYQQ5z9e9sjmFXNie8QZ0q7IP5oQ7Kyqlicaw==" media="screen">

</head>

<body>

<div class="preloader"></div>

  <div class="header-height-fix"></div>
<header class="header-nav">
  <div class="container">
    <div class="row">
      <div class="col-12">
        <nav class="navbar navbar-expand-lg navbar-light p-0">
          <a class="navbar-brand font-weight-bold mr-0" href="/">

            <img loading="lazy" src="/images/logo.png" alt="GeeKery" height="40px">

          </a>


          <button class="search-toggle d-inline-block d-lg-none ml-auto mr-3" data-toggle="search" aria-label="Search Toggle">
            <i class="las la-search"></i>
          </button>


          <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navHeader" aria-controls="navHeader" aria-expanded="false" aria-label="Toggle navigation">
            <i class="d-inline lab la-buromobelexperte"></i>
            <i class="d-none las la-times"></i>
          </button>

          <div class="collapse navbar-collapse" id="navHeader">
            <ul class="navbar-nav mx-auto">






              <li class="nav-item ">
                <a class="nav-link" href="/">Home</a>
              </li>





              <li class="nav-item ">
                <a class="nav-link" href="/author">Author</a>
              </li>





              <li class="nav-item ">
                <a class="nav-link" href="/categories">Categories</a>
              </li>





              <li class="nav-item dropdown">
                <a class="nav-link dropdown-toggle d-inline-block " href="#" role="button" data-toggle="dropdown" aria-expanded="false">Archives</a>
                <ul class="dropdown-menu">

                  <li><a class="dropdown-item " href="/categories">Category</a></li>

                </ul>
              </li>





              <li class="nav-item ">
                <a class="nav-link" href="/tags">Tags</a>
              </li>





              <li class="nav-item ">
                <a class="nav-link" href="/about">About</a>
              </li>


            </ul>


            <div class="navbar-right d-none d-lg-inline-block">
              <ul class="social-links list-unstyled list-inline">
                <li class="list-inline-item ml-4 d-none d-lg-inline-block">
                  <button class="search-toggle" data-toggle="search" aria-label="Search Toggle">
                    <i class="las la-search"></i>
                  </button>
                </li>
              </ul>
            </div>

          </div>
        </nav>
      </div>
    </div>
  </div>
</header>


<div class="search-block">
  <div data-toggle="search-close">
    <i class="las la-times text-primary"></i>
  </div>
  <form action="/search">
    <input id="search-query" name="s" type="search" placeholder="输入 &amp; 回车" class="text-center" aria-label="search-query">
  </form>
</div>



  <section class="section-sm pb-2 page-header">
  <div class="container">
    <div class="row">
      <div class="col-8 mx-auto text-center">


        <h3 class="mb-3 text-dark font-weight-bold">JavaScript：this机制</h3>



        <ul class="list-inline breadcrumb-menu">


        <li class="list-inline-item"><a href="/">Home</a></li>



        <li class="list-inline-item">/ &nbsp; <a href="/postsjavascriptthis%E6%9C%BA%E5%88%B6">Postsjavascriptthis% e6%9 c% b a% e5%88% b6</a></li>



        </ul>
      </div>
    </div>
  </div>
</section>






<section class="section-sm">
  <div class="container">
    <div class="row justify-content-center">
      <div class="col-lg-10">
        <div class="text-center mb-5">
          <h3 class="h2 mb-4 post-title">JavaScript：this机制</h3>
          <ul class="card-meta list-inline">
            <li class="list-inline-item">
              <a href="#!" class="card-meta-author">

                <a href="/" class="card-meta-author">
                  <img loading="lazy" src="/" alt="GeeKery">
                  <span>GeeKery</span>
                </a>

              </a>
            </li>
            <li class="list-inline-item">|</li>
            <li class="list-inline-item">
              <span>19 January 2021</span>
            </li>
          </ul>
        </div>



        <div class="content">
          <h2 id="关于-this">关于 this</h2>
<p>如果对于有经验的 JavaScript 开发者来说，this 都是一种非常复杂的机制，那它到底有用在哪里呢？下面来解释一下为什么要使用 this：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> identify() {
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">this</span>.name.toUpperCase();
}

<span style="color:#6ab825;font-weight:bold">var</span> me = {
    name: <span style="color:#ed9d13">&#34;Kyle&#34;</span>
};
<span style="color:#6ab825;font-weight:bold">var</span> you = {
    name: <span style="color:#ed9d13">&#34;Reader&#34;</span>
};
identify.call(me);    <span style="color:#999;font-style:italic">// Kyle
</span><span style="color:#999;font-style:italic"></span>identify.call(you);   <span style="color:#999;font-style:italic">// Reader
</span></code></pre></div><p>这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify，不用针对每个对象编写不同版本的函数。如果不使用 this，那就需要给 identify 显式传入一个上下文对象。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> identify(context) {
    <span style="color:#6ab825;font-weight:bold">return</span> context.name.toUpperCase();
}

<span style="color:#6ab825;font-weight:bold">var</span> me = {
    name: <span style="color:#ed9d13">&#34;Kyle&#34;</span>
};
<span style="color:#6ab825;font-weight:bold">var</span> you = {
    name: <span style="color:#ed9d13">&#34;Reader&#34;</span>
};
identify(me);    <span style="color:#999;font-style:italic">// Kyle
</span><span style="color:#999;font-style:italic"></span>identify(you);   <span style="color:#999;font-style:italic">// Reader
</span></code></pre></div><p>this 提供了一种更优雅的方式来隐式”传递“一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。随着使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。</p>
<h2 id="绑定规则">绑定规则</h2>
<p><strong>this 的绑定和函数声明的位置没有任何关系，this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</strong>。</p>
<p>当一个函数被调用时，会创建一个执行上下文。这个上下文会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p>
<h3 id="默认绑定">默认绑定</h3>
<p>独立函数调用是最常见的函数调用，也是 this 绑定的默认规则。<strong>严格模式下，this 将指向 undefined，非严格模式下将指向全局对象</strong>。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
	console.log( <span style="color:#6ab825;font-weight:bold">this</span>.a );
}

<span style="color:#6ab825;font-weight:bold">var</span> a = <span style="color:#3677a9">2</span>;
foo(); 			<span style="color:#999;font-style:italic">// 2
</span></code></pre></div><h3 id="隐式绑定">隐式绑定</h3>
<p>隐式绑定需要考虑的是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>,
    foo: foo
};
obj.foo(); <span style="color:#999;font-style:italic">// 2
</span></code></pre></div><p>调用位置会使用 obj 上下文来引用函数，即函数被调用时 obj 对象“拥有”或者“包含”函数。隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调用 foo 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p>
<p><strong>对象属性引用链中只有最顶层或者说最靠近函数调用的那一层会影响 this 指向</strong>，举例来说：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj2 = {
    a: <span style="color:#3677a9">42</span>,
    foo: foo
};
<span style="color:#6ab825;font-weight:bold">var</span> obj1 = {
    a: <span style="color:#3677a9">2</span>,
    obj2: obj2
};
obj1.obj2.foo(); <span style="color:#999;font-style:italic">// 42，this 受 obj2 影响
</span></code></pre></div><h4 id="隐式丢失">隐式丢失</h4>
<p>一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>,
    foo: foo
};
<span style="color:#6ab825;font-weight:bold">var</span> bar = obj.foo;        <span style="color:#999;font-style:italic">// 函数别名！
</span><span style="color:#999;font-style:italic"></span><span style="color:#6ab825;font-weight:bold">var</span> a = <span style="color:#ed9d13">&#34;oops, global&#34;</span>;   <span style="color:#999;font-style:italic">// a 是全局对象的属性
</span><span style="color:#999;font-style:italic"></span>bar();                    <span style="color:#999;font-style:italic">// &#34;oops, global&#34;
</span></code></pre></div><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">function</span> doFoo(fn) {
    <span style="color:#999;font-style:italic">// fn 其实引用的是 foo
</span><span style="color:#999;font-style:italic"></span>    fn(); <span style="color:#999;font-style:italic">// &lt;-- 调用位置!
</span><span style="color:#999;font-style:italic"></span>}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>,
    foo: foo
};
<span style="color:#6ab825;font-weight:bold">var</span> a = <span style="color:#ed9d13">&#34;oops, global&#34;</span>; <span style="color:#999;font-style:italic">// a 是全局对象的属性
</span><span style="color:#999;font-style:italic"></span>doFoo( obj.foo );       <span style="color:#999;font-style:italic">// &#34;oops, global&#34;
</span></code></pre></div><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一个例子一样。如果把函数传入语言内置的函数而不是传入你自己声明的函数，会发生什么呢？结果是一样的，没有区别：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>,
    foo: foo
};
<span style="color:#6ab825;font-weight:bold">var</span> a = <span style="color:#ed9d13">&#34;oops, global&#34;</span>;    <span style="color:#999;font-style:italic">// a 是全局对象的属性
</span><span style="color:#999;font-style:italic"></span>setTimeout(obj.foo, <span style="color:#3677a9">100</span>);  <span style="color:#999;font-style:italic">// &#34;oops, global&#34;
</span></code></pre></div><p>JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> setTimeout(fn, delay) {
    fn(); <span style="color:#999;font-style:italic">// &lt;-- 调用位置!
</span><span style="color:#999;font-style:italic"></span>}
</code></pre></div><p>就像我们看到的那样，回调函数丢失 this 绑定是非常常见的。除此之外，还有一种情况 this 的行为会出乎我们意料：调用回调函数的函数可能会修改 this。在一些 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。<strong>实际上你无法控制回调函数的执行方式，因此就没有办法控制会影响绑定的调用位置</strong>。</p>
<h3 id="显示绑定">显示绑定</h3>
<p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接（隐式）绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢？
可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自己创建的所有函数都可以使用 call(..) 和 apply(..) 方法。这两个方法是如何工作的呢？它们的第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。因为你可以直接指定 this 的绑定对象，因此我们称之为显式绑定。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>
};
foo.call(obj); <span style="color:#999;font-style:italic">// 2
</span></code></pre></div><p>通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是new String(..)、new Boolean(..)或者 new Number(..)），这通常被称为“装箱”。</p>
<p>由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.bind，它的用法如下：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo(something) {
    console.log(<span style="color:#6ab825;font-weight:bold">this</span>.a, something);
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">this</span>.a + something;
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>
};
<span style="color:#6ab825;font-weight:bold">var</span> bar = foo.bind(obj);
<span style="color:#6ab825;font-weight:bold">var</span> b = bar(<span style="color:#3677a9">3</span>); <span style="color:#999;font-style:italic">// 2 3
</span><span style="color:#999;font-style:italic"></span>console.log(b); <span style="color:#999;font-style:italic">// 5
</span></code></pre></div><p><strong>bind(..) 会返回一个硬编码的新函数，它会把参数设置为 this 的上下文并调用原始函数</strong>。</p>
<p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为“上下文”（context），其作用和 bind(..) 一样，确保你的回调 函数使用指定的 this。举例来说：</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo(el) {
    console.log(el, <span style="color:#6ab825;font-weight:bold">this</span>.id);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    id: <span style="color:#ed9d13">&#34;awesome&#34;</span>
};
<span style="color:#999;font-style:italic">// 调用 foo(..) 时把 this 绑定到 obj
</span><span style="color:#999;font-style:italic"></span>[<span style="color:#3677a9">1</span>, <span style="color:#3677a9">2</span>, <span style="color:#3677a9">3</span>].forEach(foo, obj);
<span style="color:#999;font-style:italic">// 1 awesome 2 awesome 3 awesome
</span></code></pre></div><p>这些函数实际上就是通过 call(..) 或者 apply(..) 实现了显式绑定，这样可以少些一些代码。</p>
<h3 id="new-绑定">new 绑定</h3>
<p>在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。</p>
<p>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>
<p>创建（或者说构造）一个全新的对象。</p>
</li>
<li>
<p>这个新对象会被执行 [[原型]] 连接。</p>
</li>
<li>
<p>这个新对象会绑定到函数调用的 this。</p>
</li>
<li>
<p>如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo(a) {
    <span style="color:#6ab825;font-weight:bold">this</span>.a = a;
}

<span style="color:#6ab825;font-weight:bold">var</span> bar = <span style="color:#6ab825;font-weight:bold">new</span> foo(<span style="color:#3677a9">2</span>);
console.log(bar.a); <span style="color:#999;font-style:italic">// 2
</span></code></pre></div></li>
</ol>
<p>使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。</p>
<h2 id="优先级">优先级</h2>
<p>现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的
顺序来进行判断:</p>
<ol>
<li>由 new 调用：绑定到新创建的对象。</li>
<li>由 call、apply 或者 bind 调用：绑定到指定的对象。</li>
<li>由上下文对象调用：绑定到那个上下文对象。</li>
<li>默认：在严格模式下绑定到 undefined，否则绑定到全局对象。</li>
</ol>
<h2 id="绑定例外">绑定例外</h2>
<p>我们之前介绍的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数。箭头函数并不是使用 function 关键字定义的，而是使用 =&gt; 定义的。箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this，箭头函数的 this 指向的是外部作用域中的 this。</p>
<p>箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前就已经在使用一种几乎和箭头函数完全一样的模式。</p>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#6ab825;font-weight:bold">function</span> foo() {
    <span style="color:#6ab825;font-weight:bold">var</span> self = <span style="color:#6ab825;font-weight:bold">this</span>; <span style="color:#999;font-style:italic">// lexical capture of this
</span><span style="color:#999;font-style:italic"></span>    setTimeout(<span style="color:#6ab825;font-weight:bold">function</span> () {
        console.log(self.a);
    }, <span style="color:#3677a9">100</span>);
}

<span style="color:#6ab825;font-weight:bold">var</span> obj = {
    a: <span style="color:#3677a9">2</span>
};
foo.call(obj); <span style="color:#999;font-style:italic">// 2
</span></code></pre></div><p>虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。</p>
<h2 id="总结">总结</h2>
<p>要判断一个运行中函数的 this 绑定，就需要找到这个<strong>函数的直接调用位置</strong>。找到之后就可以顺序上述优先级来判断 this 的绑定对象。要注意有些调用可能在无意中导致隐式丢失而使用默认绑定规则。</p>
<p>如果想”更安全“地忽略 this 绑定，你可以使用一个 DMZ 对象，比如 ø = Object.create(null)，以保护全局对象。</p>
<p>ES6 中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定 this，具体来说，箭头函数会继承外层函数调用的 this 绑定。这其实和 ES6 之前代码中的 self = this 机制一样。</p>
<h2 id="附实现-callapplybind">附：实现 call、apply、bind</h2>
<div class="highlight"><pre style="color:#d0d0d0;background-color:#202020;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#24909d">Function</span>.prototype.customCall = <span style="color:#6ab825;font-weight:bold">function</span> (context = <span style="color:#24909d">Object</span>.create(<span style="color:#6ab825;font-weight:bold">null</span>), ...args) {
    context.fn = <span style="color:#6ab825;font-weight:bold">this</span>;    <span style="color:#999;font-style:italic">// this 是调用 call 的函数
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">const</span> result = context.fn(...args);
    <span style="color:#6ab825;font-weight:bold">delete</span> context.fn;    <span style="color:#999;font-style:italic">// 执行后删除新增属性
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> result;
}

<span style="color:#24909d">Function</span>.prototype.customApply = <span style="color:#6ab825;font-weight:bold">function</span> (context = <span style="color:#24909d">Object</span>.create(<span style="color:#6ab825;font-weight:bold">null</span>), args = []) {
    context.fn = <span style="color:#6ab825;font-weight:bold">this</span>;    <span style="color:#999;font-style:italic">// this 是调用 call 的函数
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">const</span> result = context.fn(...args);
    <span style="color:#6ab825;font-weight:bold">delete</span> context.fn;    <span style="color:#999;font-style:italic">// 执行后删除新增属性
</span><span style="color:#999;font-style:italic"></span>    <span style="color:#6ab825;font-weight:bold">return</span> result;
}

<span style="color:#24909d">Function</span>.prototype.customBind = <span style="color:#6ab825;font-weight:bold">function</span> (context, ...args) {
    <span style="color:#6ab825;font-weight:bold">const</span> _this = <span style="color:#6ab825;font-weight:bold">this</span>;
    <span style="color:#6ab825;font-weight:bold">return</span> <span style="color:#6ab825;font-weight:bold">function</span> Bind(...newArgs) {
        <span style="color:#999;font-style:italic">// 考虑是否此函数被继承
</span><span style="color:#999;font-style:italic"></span>        <span style="color:#6ab825;font-weight:bold">if</span> (<span style="color:#6ab825;font-weight:bold">this</span> <span style="color:#6ab825;font-weight:bold">instanceof</span> Bind) {
            <span style="color:#6ab825;font-weight:bold">return</span> _this.customApply(<span style="color:#6ab825;font-weight:bold">this</span>, [...args, ...newArgs])
        }
        <span style="color:#6ab825;font-weight:bold">return</span> _this.customApply(context, [...args, ...newArgs])
    }
}
</code></pre></div><p>上述 call 和 apply 的实现，实际情况需要考虑应用上下文是否可写，在向应用上下文写入调用函数时，最好使用 Symbol 属性，防止覆盖应用上下文原本的内容。手动实现没有什么意义，重点还是要理解 this。</p>

        </div>
      </div>
    </div>

    <div class="single-post-meta">
      <div class="row justify-content-center">
        <div class="col-lg-5 col-md-6 text-center text-md-left">
          <ul class="post-meta-tags list-unstyled list-inline">

            <li class="list-inline-item"><a href="/tags/js%E7%B3%BB%E5%88%97">JS系列</a></li>

          </ul>
        </div>
        <div class="col-lg-5 col-md-6 text-center text-md-right mt-4 mt-md-0">
<ul class="social-links has-bg-color list-unstyled list-inline" style="line-height:0">
  <li class="list-inline-item">

    <a class="resp-sharing-button__link d-block" href="https://facebook.com/sharer/sharer.php?u=%2fposts%2fjavascriptthis%25E6%259C%25BA%25E5%2588%25B6%2f" target="_blank"
      rel="noopener" aria-label="">
      <div class="resp-sharing-button resp-sharing-button--facebook resp-sharing-button--small">
        <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
          <i class="lab la-facebook-f text-dark"></i>
        </div>
      </div>
    </a>
  </li>

  <li class="list-inline-item">

    <a class="resp-sharing-button__link d-block" href="https://twitter.com/intent/tweet/?text=JavaScript%ef%bc%9athis%e6%9c%ba%e5%88%b6&amp;url=%2fposts%2fjavascriptthis%25E6%259C%25BA%25E5%2588%25B6%2f"
      target="_blank" rel="noopener" aria-label="">
      <div class="resp-sharing-button resp-sharing-button--twitter resp-sharing-button--small">
        <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
          <i class="lab la-twitter text-dark"></i>
        </div>
      </div>
    </a>
  </li>

  <li class="list-inline-item">

    <a class="resp-sharing-button__link d-block" href="https://plus.google.com/share?url=%2fposts%2fjavascriptthis%25E6%259C%25BA%25E5%2588%25B6%2f" target="_blank"
      rel="noopener" aria-label="">
      <div class="resp-sharing-button resp-sharing-button--google resp-sharing-button--small">
        <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
          <i class="lab la-google-plus-g text-dark"></i>
        </div>
      </div>
    </a>
  </li>

  <li class="list-inline-item">

    <a class="resp-sharing-button__link d-block" href="mailto:?subject=JavaScript%ef%bc%9athis%e6%9c%ba%e5%88%b6&amp;body=%2fposts%2fjavascriptthis%25E6%259C%25BA%25E5%2588%25B6%2f" target="_self"
      rel="noopener" aria-label="">
      <div class="resp-sharing-button resp-sharing-button--email resp-sharing-button--small">
        <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
          <i class="las la-envelope text-dark"></i>
        </div>
      </div>
    </a>
  </li>

  <li class="list-inline-item">

    <a class="resp-sharing-button__link d-block" href="whatsapp://send?text=JavaScript%ef%bc%9athis%e6%9c%ba%e5%88%b6%20%2fposts%2fjavascriptthis%25E6%259C%25BA%25E5%2588%25B6%2f" target="_blank"
      rel="noopener" aria-label="">
      <div class="resp-sharing-button resp-sharing-button--whatsapp resp-sharing-button--small">
        <div aria-hidden="true" class="resp-sharing-button__icon resp-sharing-button__icon--solid">
          <i class="lab la-whatsapp text-dark"></i>
        </div>
      </div>
    </a>
  </li>

</ul></div>
      </div>
    </div>

    <div class="single-post-author">
      <div class="row justify-content-center">
        <div class="col-lg-10">
          <div class="media d-block d-sm-flex text-center text-sm-left">

            <a href="/"><img loading="lazy" class="img-fluid rounded-circle mr-0 mr-sm-4 mb-4" src="/" alt="GeeKery"></a>
            <div class="media-body">
              <p class="font-primary mb-1">Written By</p>
              <h4><a href="/" class="text-dark font-weight-700">GeeKery</a></h4>
              <p class="font-primary"></p>
              <ul class="social-links list-unstyled list-inline ml-0 ml-sm-n2">

              </ul>
            </div>

          </div>
        </div>
      </div>
    </div>

    <div class="single-post-similer">
      <div class="row justify-content-center">
        <div class="col-lg-10">
          <div class="row mt-3">
            <div class="col-12">
              <h3 class="text-dark font-weight-800 mb-4 pb-2">You May Also Like</h3>
            </div>


            <div class="col-md-6">
              <article class="card post-card">

  <div class="card-body">
    <ul class="card-meta list-inline mb-2">
      <li class="list-inline-item mb-2">

        <a href="/" class="card-meta-author">

          <img loading="lazy" src="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=150&pg&d=identicon">

          <span>GeeKery</span>
        </a>

      </li>
      <li class="list-inline-item mb-2">
        <span>19 Jan, 2021</span>
      </li>
      <li class="list-inline-item mb-2">
        <ul class="card-meta-tag list-inline">

          <li class="list-inline-item"><a href="/tags/js%E7%B3%BB%E5%88%97">JS系列</a></li>

        </ul>
      </li>
    </ul>
    <h3 class="mb-3">
      <a class="post-title" href="/posts/javascript%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">JavaScript：内存管理</a>
    </h3>
    <p>内存的生命周期包括分配内存、使用内存和释放内存。有些语言（比如 C 语言）必须手动分配和释放内存，JavaScript 的内存分配过程是在做变量声明赋值时自动完成的。变量完成内存分配之后程序才可以使用进行读写。当程序不需要再使用某些变量时，它们占用的内存就会进行释放，腾出空间。
内存溢出 程序的运行 …</p>


  </div>
</article>
            </div>

            <div class="col-md-6">
              <article class="card post-card">

  <div class="card-body">
    <ul class="card-meta list-inline mb-2">
      <li class="list-inline-item mb-2">

        <a href="/" class="card-meta-author">

          <img loading="lazy" src="https://www.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e?s=150&pg&d=identicon">

          <span>GeeKery</span>
        </a>

      </li>
      <li class="list-inline-item mb-2">
        <span>18 Jan, 2021</span>
      </li>
      <li class="list-inline-item mb-2">
        <ul class="card-meta-tag list-inline">

          <li class="list-inline-item"><a href="/tags/js%E7%B3%BB%E5%88%97">JS系列</a></li>

        </ul>
      </li>
    </ul>
    <h3 class="mb-3">
      <a class="post-title" href="/posts/javascript%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%97%AD%E5%8C%85/">JavaScript：作用域和闭包</a>
    </h3>
    <p>词法作用域 作用域是一套规则，这套规则用来管理引擎如何在当前的作用域以及嵌套的子作用域中根据标识符名称进行变量查找。作用域共有两种主要的工作模型。第一种是最为普遍的，被大多数编程语言所采用的词法作用域，另外一种叫做动态作用域，仍有一些编程语言在使用（比如 Bash 脚本、Perl 中的一些模式 …</p>


  </div>
</article>
            </div>

          </div>
        </div>
      </div>
    </div>
  </div>
</section>




  <footer class="section-sm">
  <div class="container">
    <div class="row justify-content-center align-items-center">
      <div class="col-lg-5">



      </div>
      <div class="col-lg-12 text-center mt-5">
        <ul class="list-inline footer-menu mb-4">

        </ul>
        <ul class="social-links icon-box list-unstyled list-inline font-weight-500 mb-3">

          <li class="list-inline-item text-center"><a href="https://www.linkedin.com/in/jayden-deng-3654b1176" aria-label="social-icon">
            <i class="lab lab la-linkedin-in"></i>
          </a></li>

          <li class="list-inline-item text-center"><a href="mailto:mailto:dqy676081195@gmail.com" aria-label="social-icon">
            <i class="lab las la-at"></i>
          </a></li>

          <li class="list-inline-item text-center"><a href="https://github.com/GeeKeryK" aria-label="social-icon">
            <i class="lab lab la-github"></i>
          </a></li>

        </ul>

        <p class="mb-0 font-weight-500 copyright-text content">Copyright © 2021 GeeKery</p>

      </div>
    </div>
  </div>
</footer>






























<script data-turbolinks-suppress-warning src="/js/vendor.min.145a21dc1d3b6180ba4053b597f77d01206a5207dbc280de83d4151958109b94fad45e42ce423c4c4cf0cef270a67279b4db5d19f05e3eee33b3838de0028318.js" integrity="sha512-FFoh3B07YYC6QFO1l/d9ASBqUgfbwoDeg9QVGVgQm5T61F5CzkI8TEzwzvJwpnJ5tNtdGfBePu4zs4ON4AKDGA=="></script>



</body>

</html>
